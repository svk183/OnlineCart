"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const internal_compatibility_1 = require("rxjs/internal-compatibility");
const path_1 = require("path");
const workspace_1 = require("@nrwl/workspace");
const legacy_1 = require("./legacy");
const literals_1 = require("@angular-devkit/core/src/utils/literals");
const Cypress = require('cypress'); // @NOTE: Importing via ES6 messes the whole test dependencies.
try {
    require('dotenv').config();
}
catch (e) { }
exports.default = architect_1.createBuilder(run);
/**
 * @whatItDoes This is the starting point of the builder.
 * @param options
 * @param context
 */
function run(options, context) {
    const legacy = isLegacy(options, context);
    if (legacy) {
        showLegacyWarning(context);
    }
    options.env = options.env || {};
    if (options.tsConfig) {
        options.env.tsConfig = path_1.join(context.workspaceRoot, options.tsConfig);
    }
    return (!legacy
        ? options.devServerTarget
            ? startDevServer(options.devServerTarget, options.watch, context)
            : rxjs_1.of(options.baseUrl)
        : legacy_1.legacyCompile(options, context)).pipe(operators_1.concatMap((baseUrl) => initCypress(options.cypressConfig, options.headless, options.exit, options.record, options.key, options.parallel, options.watch, baseUrl, options.browser, options.env, options.spec, options.ciBuildId)), options.watch ? operators_1.tap(rxjs_1.noop) : operators_1.take(1), operators_1.catchError(error => {
        context.reportStatus(`Error: ${error.message}`);
        context.logger.error(error.message);
        return rxjs_1.of({
            success: false
        });
    }));
}
/**
 * @whatItDoes Initialize the Cypress test runner with the provided project configuration.
 * If `headless` is `false`: open the Cypress application, the user will
 * be able to interact directly with the application.
 * If `headless` is `true`: Cypress will run in headless mode and will
 * provide directly the results in the console output.
 * @param cypressConfig
 * @param headless
 * @param exit
 * @param record
 * @param key
 * @param parallel
 * @param baseUrl
 * @param isWatching
 * @param browser
 * @param env
 * @param spec
 * @param ciBuildId
 */
function initCypress(cypressConfig, headless, exit, record, key, parallel, isWatching, baseUrl, browser, env, spec, ciBuildId) {
    // Cypress expects the folder where a `cypress.json` is present
    const projectFolderPath = path_1.dirname(cypressConfig);
    const options = {
        project: projectFolderPath
    };
    // If not, will use the `baseUrl` normally from `cypress.json`
    if (baseUrl) {
        options.config = { baseUrl: baseUrl };
    }
    if (browser) {
        options.browser = browser;
    }
    if (env) {
        options.env = env;
    }
    if (spec) {
        options.spec = spec;
    }
    options.exit = exit;
    options.headed = !headless;
    options.record = record;
    options.key = key;
    options.parallel = parallel;
    options.ciBuildId = ciBuildId;
    return internal_compatibility_1.fromPromise(!isWatching || headless ? Cypress.run(options) : Cypress.open(options)).pipe(
    // tap(() => (isWatching && !headless ? process.exit() : null)), // Forcing `cypress.open` to give back the terminal
    operators_1.map(result => ({
        /**
         * `cypress.open` is returning `0` and is not of the same type as `cypress.run`.
         * `cypress.open` is the graphical UI, so it will be obvious to know what wasn't
         * working. Forcing the build to success when `cypress.open` is used.
         */
        success: !result.totalFailed && !result.failures
    })));
}
/**
 * @whatItDoes Compile the application using the webpack builder.
 * @param devServerTarget
 * @param isWatching
 * @param context
 * @private
 */
function startDevServer(devServerTarget, isWatching, context) {
    // Overrides dev server watch setting.
    const overrides = {
        watch: isWatching
    };
    return architect_1.scheduleTargetAndForget(context, architect_1.targetFromTargetString(devServerTarget), overrides).pipe(operators_1.map(output => {
        if (!output.success && !isWatching) {
            throw new Error('Could not compile application files');
        }
        return output.baseUrl;
    }));
}
exports.startDevServer = startDevServer;
function isLegacy(options, context) {
    const tsconfigJson = workspace_1.readJsonFile(path_1.join(context.workspaceRoot, options.tsConfig));
    const cypressConfigPath = path_1.join(context.workspaceRoot, options.cypressConfig);
    const cypressJson = workspace_1.readJsonFile(cypressConfigPath);
    if (!cypressJson.integrationFolder) {
        throw new Error(`"integrationFolder" is not defined in ${options.cypressConfig}`);
    }
    const integrationFolder = path_1.join(path_1.dirname(cypressConfigPath), cypressJson.integrationFolder);
    const tsOutDirPath = path_1.join(context.workspaceRoot, path_1.dirname(options.tsConfig), tsconfigJson.compilerOptions.outDir);
    return !path_1.relative(tsOutDirPath, integrationFolder).startsWith('..');
}
function showLegacyWarning(context) {
    context.logger.warn(literals_1.stripIndents `
  Warning:
  You are using the legacy configuration for cypress.
  Please run "ng update @nrwl/cypress --from 8.1.0 --to 8.2.0 --migrate-only".`);
}
