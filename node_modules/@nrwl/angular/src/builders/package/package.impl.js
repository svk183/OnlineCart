"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const literals_1 = require("@angular-devkit/core/src/utils/literals");
const ng = require("@angular/compiler-cli");
const workspace_1 = require("@nrwl/workspace");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const fileutils_1 = require("@nrwl/workspace/src/utils/fileutils");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
/**
 * It is a prerequisite that dependent libraries have been built before the parent
 * library. This function checks that
 * @param context
 */
function checkDependentLibrariesHaveBeenBuilt(context, projectDependencies) {
    const depLibsToBuildFirst = [];
    // verify whether all dependent libraries have been built
    projectDependencies.forEach(libDep => {
        // check wether dependent library has been built => that's necessary
        const packageJsonPath = path_1.join(context.workspaceRoot, 'dist', libDep.node.data.root, 'package.json');
        if (!fileutils_1.fileExists(packageJsonPath)) {
            depLibsToBuildFirst.push(libDep);
        }
    });
    if (depLibsToBuildFirst.length > 0) {
        context.logger.error(literals_1.stripIndents `
      Some of the library ${context.target.project}'s dependencies have not been built yet. Please build these libraries before:
      ${depLibsToBuildFirst.map(x => ` - ${x.node.name}`).join('\n')}

      Try: nx run-many --target build --projects ${context.target.project},...
    `);
        return { success: false };
    }
    else {
        return { success: true };
    }
}
function initializeNgPackagr(options, context, projectDependencies) {
    return __awaiter(this, void 0, void 0, function* () {
        const packager = (yield Promise.resolve().then(() => require('ng-packagr'))).ngPackagr();
        packager.forProject(path_1.resolve(context.workspaceRoot, options.project));
        if (options.tsConfig) {
            // read the tsconfig and modify its path in memory to
            // pass it on to ngpackagr
            const parsedTSConfig = ng.readConfiguration(options.tsConfig);
            // update the tsconfig.lib.json => we only do this in memory
            // and pass it along to ng-packagr
            projectDependencies.forEach(libDep => {
                parsedTSConfig.options.paths[libDep.scope] = [
                    libDep.outputPath,
                    ...parsedTSConfig.options.paths[libDep.scope]
                ];
            });
            packager.withTsConfig(parsedTSConfig);
        }
        return packager;
    });
}
/**
 * Given a target library, uses the project dep graph to find all its dependencies
 * and calculates the `scope` name and output path
 * @param targetProj the target library to build
 */
function calculateLibraryDependencies(context) {
    const targetProj = context.target.project;
    const projGraph = project_graph_1.createProjectGraph();
    const hasArchitectBuildBuilder = (projectGraph) => projectGraph.data.architect &&
        projectGraph.data.architect.build &&
        projectGraph.data.architect.build.builder !== '';
    // gather the library dependencies
    return (projGraph.dependencies[targetProj] || [])
        .map(dependency => {
        const depNode = projGraph.nodes[dependency.target];
        if (depNode.type === project_graph_1.ProjectType.lib &&
            hasArchitectBuildBuilder(depNode)) {
            const libPackageJson = workspace_1.readJsonFile(path_1.join(context.workspaceRoot, depNode.data.root, 'package.json'));
            return {
                scope: libPackageJson.name,
                outputPath: `dist/${depNode.data.root}`,
                node: depNode
            };
        }
        else {
            return null;
        }
    })
        .filter(x => !!x);
}
exports.calculateLibraryDependencies = calculateLibraryDependencies;
/**
 * Updates the peerDependencies section in the `dist/lib/xyz/package.json` with
 * the proper dependency and version
 */
function updatePackageJsonDependencies(context, libDependencies) {
    const targetProject = context.target.project;
    const projGraph = project_graph_1.createProjectGraph();
    const targetProjNode = projGraph.nodes[targetProject];
    let distLibOutputPath = `dist/${targetProjNode.data.root}`;
    // if we have dependencies, update the `dependencies` section of the package.json
    const jsonOutputFile = `${distLibOutputPath}/package.json`;
    if (libDependencies && libDependencies.length > 0) {
        const outputJson = workspace_1.readJsonFile(jsonOutputFile);
        outputJson.dependencies = outputJson.dependencies || {};
        libDependencies.forEach(entry => {
            if (!outputJson.dependencies[entry.scope]) {
                // read the lib version (should we read the one from the dist?)
                const packageJsonPath = path_1.join(context.workspaceRoot, entry.node.data.root, 'package.json');
                const depNodePackageJson = workspace_1.readJsonFile(packageJsonPath);
                outputJson.dependencies[entry.scope] = depNodePackageJson.version;
            }
        });
        fileutils_1.writeJsonFile(jsonOutputFile, outputJson);
    }
}
function run(options, context) {
    const dependencies = calculateLibraryDependencies(context);
    return rxjs_1.of(checkDependentLibrariesHaveBeenBuilt(context, dependencies)).pipe(operators_1.switchMap(result => {
        if (result.success) {
            return rxjs_1.from(initializeNgPackagr(options, context, dependencies)).pipe(operators_1.switchMap(packager => options.watch ? packager.watch() : packager.build()), operators_1.tap(() => {
                updatePackageJsonDependencies(context, dependencies);
            }), operators_1.mapTo({ success: true }));
        }
        else {
            // just pass on the result
            return rxjs_1.of(result);
        }
    }));
}
exports.run = run;
exports.default = architect_1.createBuilder(run);
