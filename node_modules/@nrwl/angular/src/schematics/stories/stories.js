"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const typescript_1 = require("typescript");
const ast_utils_1 = require("../../utils/ast-utils");
function default_1(schema) {
    return schematics_1.chain([createAllStories(schema.name, schema.generateCypressSpecs)]);
}
exports.default = default_1;
function createAllStories(projectName, generateCypressSpecs) {
    return (tree, context) => {
        context.logger.debug('adding .storybook folder to lib');
        const libPath = workspace_1.getProjectConfig(tree, projectName).sourceRoot + '/lib';
        return schematics_1.chain(tree
            .getDir(libPath)
            .subfiles.filter(fileName => fileName.endsWith('.module.ts'))
            .map(fileName => {
            const filePath = libPath + '/' + fileName;
            const file = ast_utils_1.getTsSourceFile(tree, filePath);
            const ngModuleDecorators = ast_utils_1.getDecoratorMetadata(file, 'NgModule', '@angular/core');
            if (ngModuleDecorators.length === 0) {
                throw new schematics_1.SchematicsException(`No @NgModule decorator in ${filePath}`);
            }
            const ngModuleDecorator = ngModuleDecorators[0];
            const syntaxList = ngModuleDecorator.getChildren().find(node => {
                return node.kind === typescript_1.SyntaxKind.SyntaxList;
            });
            const declarationsPropertyAssignment = syntaxList
                .getChildren()
                .find(node => {
                return (node.kind === typescript_1.SyntaxKind.PropertyAssignment &&
                    node.getChildren()[0].getText() === 'declarations');
            });
            if (!declarationsPropertyAssignment) {
                throw new schematics_1.SchematicsException(`No declarations array in the @NgModule decorator in ${filePath}`);
            }
            const declaredComponents = declarationsPropertyAssignment
                .getChildren()
                .find(node => node.kind === typescript_1.SyntaxKind.ArrayLiteralExpression)
                .getChildren()
                .find(node => node.kind === typescript_1.SyntaxKind.SyntaxList)
                .getChildren()
                .filter(node => node.kind === typescript_1.SyntaxKind.Identifier)
                .map(node => node.getText())
                .filter(name => name.endsWith('Component'));
            const imports = file.statements.filter(statement => statement.kind === typescript_1.SyntaxKind.ImportDeclaration);
            const componentInfo = declaredComponents.map(componentName => {
                try {
                    const importStatement = imports.find(statement => {
                        const importedIdentifiers = statement
                            .getChildren()
                            .find(node => node.kind === typescript_1.SyntaxKind.ImportClause)
                            .getChildren()
                            .find(node => node.kind === typescript_1.SyntaxKind.NamedImports)
                            .getChildren()
                            .find(node => node.kind === typescript_1.SyntaxKind.SyntaxList)
                            .getChildren()
                            .filter(node => node.kind === typescript_1.SyntaxKind.ImportSpecifier)
                            .map(node => node.getText());
                        return importedIdentifiers.includes(componentName);
                    });
                    const fullPath = importStatement
                        .getChildren()
                        .find(node => node.kind === typescript_1.SyntaxKind.StringLiteral)
                        .getText()
                        .slice(1, -1);
                    const path = fullPath.slice(0, fullPath.lastIndexOf('/'));
                    const componentFileName = fullPath.slice(fullPath.lastIndexOf('/') + 1);
                    return { name: componentName, path, componentFileName };
                }
                catch (ex) {
                    context.logger.warn(`Could not generate a story for ${componentName}.  Error: ${ex}`);
                    return undefined;
                }
            });
            return schematics_1.chain(componentInfo
                .filter(info => info !== undefined)
                .map(info => schematics_1.chain([
                schematics_1.schematic('component-story', {
                    libPath,
                    componentName: info.name,
                    componentPath: info.path,
                    componentFileName: info.componentFileName
                }),
                generateCypressSpecs
                    ? schematics_1.schematic('component-cypress-spec', {
                        projectName,
                        libPath,
                        componentName: info.name,
                        componentPath: info.path,
                        componentFileName: info.componentFileName
                    })
                    : () => { }
            ])));
        }));
    };
}
exports.createAllStories = createAllStories;
