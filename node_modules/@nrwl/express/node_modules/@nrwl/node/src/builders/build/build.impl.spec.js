"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const path_1 = require("path");
jest.mock('tsconfig-paths-webpack-plugin');
const tsconfig_paths_webpack_plugin_1 = require("tsconfig-paths-webpack-plugin");
const rxjs_1 = require("rxjs");
const buildWebpack = require("@angular-devkit/build-webpack");
const testing_1 = require("../../utils/testing");
describe('NodeBuildBuilder', () => {
    let testOptions;
    let architect;
    let runWebpack;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        [architect] = yield testing_1.getTestArchitect();
        testOptions = {
            main: 'apps/nodeapp/src/main.ts',
            tsConfig: 'apps/nodeapp/tsconfig.app.json',
            outputPath: 'dist/apps/nodeapp',
            externalDependencies: 'all',
            fileReplacements: [
                {
                    replace: 'apps/environment/environment.ts',
                    with: 'apps/environment/environment.prod.ts'
                },
                {
                    replace: 'module1.ts',
                    with: 'module2.ts'
                }
            ],
            assets: [],
            statsJson: false
        };
        runWebpack = jest.fn().mockImplementation((config, context, options) => {
            options.logging({
                toJson: () => ({
                    stats: 'stats'
                })
            });
            return rxjs_1.of({ success: true });
        });
        buildWebpack.runWebpack = runWebpack;
        spyOn(core_1.workspaces, 'readWorkspace').and.returnValue({
            workspace: {
                projects: {
                    get: () => ({
                        sourceRoot: '/root/apps/nodeapp/src'
                    })
                }
            }
        });
        tsconfig_paths_webpack_plugin_1.default.mockImplementation(function MockPathsPlugin() { });
    }));
    describe('run', () => {
        it('should call runWebpack', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/node:build', testOptions);
            yield run.output.toPromise();
            yield run.stop();
            expect(runWebpack).toHaveBeenCalled();
        }));
        it('should emit the outfile along with success', () => __awaiter(void 0, void 0, void 0, function* () {
            const run = yield architect.scheduleBuilder('@nrwl/node:build', testOptions);
            const output = yield run.output.toPromise();
            yield run.stop();
            expect(output.success).toEqual(true);
            expect(output.outfile).toEqual('/root/dist/apps/nodeapp/main.js');
        }));
        describe('webpackConfig option', () => {
            it('should require the specified function and use the return value', () => __awaiter(void 0, void 0, void 0, function* () {
                const mockFunction = jest.fn(config => ({
                    config: 'config'
                }));
                jest.mock(path_1.join(core_1.normalize('/root'), 'apps/nodeapp/webpack.config.js'), () => mockFunction, {
                    virtual: true
                });
                testOptions.webpackConfig = 'apps/nodeapp/webpack.config.js';
                const run = yield architect.scheduleBuilder('@nrwl/node:build', testOptions);
                yield run.output.toPromise();
                yield run.stop();
                expect(mockFunction).toHaveBeenCalled();
                expect(runWebpack).toHaveBeenCalledWith({
                    config: 'config'
                }, jasmine.anything(), jasmine.anything());
                // expect(runWebpack.calls.first().args[0]).toEqual({
                //   config: 'config'
                // });
            }));
        });
    });
});
