"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const workspace_1 = require("@nrwl/workspace");
const fileutils_1 = require("@nrwl/workspace/src/utils/fileutils");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const glob = require("glob");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const treeKill = require("tree-kill");
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const ts = require("typescript");
const fs_1 = require("fs");
const buildale_libs_utils_1 = require("@nrwl/workspace/src/utils/buildale-libs-utils");
/**
 * -----------------------------------------------------------
 */
exports.default = architect_1.createBuilder(runNodePackageBuilder);
function runNodePackageBuilder(options, context) {
    const projGraph = project_graph_1.createProjectGraph();
    const normalizedOptions = normalizeOptions(options, context);
    const { target, dependencies } = buildale_libs_utils_1.calculateProjectDependencies(projGraph, context);
    return rxjs_1.of(buildale_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context, dependencies)).pipe(operators_1.switchMap(result => {
        if (result) {
            return compileTypeScriptFiles(normalizedOptions, context, projGraph, dependencies).pipe(operators_1.tap(() => {
                updatePackageJson(normalizedOptions, context);
                if (dependencies.length > 0) {
                    buildale_libs_utils_1.updateBuildableProjectPackageJsonDependencies(context, target, dependencies);
                }
            }), operators_1.switchMap(() => {
                return copyAssetFiles(normalizedOptions, context);
            }));
        }
        else {
            return rxjs_1.of({ success: false });
        }
    }), operators_1.map(value => {
        return Object.assign(Object.assign({}, value), { outputPath: normalizedOptions.outputPath });
    }));
}
exports.runNodePackageBuilder = runNodePackageBuilder;
function normalizeOptions(options, context) {
    const outDir = options.outputPath;
    const files = [];
    const globbedFiles = (pattern, input = '', ignore = []) => {
        return glob.sync(pattern, {
            cwd: input,
            nodir: true,
            ignore
        });
    };
    options.assets.forEach(asset => {
        if (typeof asset === 'string') {
            globbedFiles(asset, context.workspaceRoot).forEach(globbedFile => {
                files.push({
                    input: path_1.join(context.workspaceRoot, globbedFile),
                    output: path_1.join(context.workspaceRoot, outDir, path_1.basename(globbedFile))
                });
            });
        }
        else {
            globbedFiles(asset.glob, path_1.join(context.workspaceRoot, asset.input), asset.ignore).forEach(globbedFile => {
                files.push({
                    input: path_1.join(context.workspaceRoot, asset.input, globbedFile),
                    output: path_1.join(context.workspaceRoot, outDir, asset.output, globbedFile)
                });
            });
        }
    });
    // Relative path for the dist directory
    const tsconfig = workspace_1.readJsonFile(path_1.join(context.workspaceRoot, options.tsConfig));
    const rootDir = tsconfig.compilerOptions.rootDir || '';
    const mainFileDir = path_1.dirname(options.main);
    const tsconfigDir = path_1.dirname(options.tsConfig);
    const relativeMainFileOutput = path_1.relative(`${tsconfigDir}/${rootDir}`, mainFileDir);
    return Object.assign(Object.assign({}, options), { files,
        relativeMainFileOutput, normalizedOutputPath: path_1.join(context.workspaceRoot, options.outputPath) });
}
let tscProcess;
function compileTypeScriptFiles(options, context, projGraph, projectDependencies) {
    if (tscProcess) {
        killProcess(context);
    }
    // Cleaning the /dist folder
    fs_extra_1.removeSync(options.normalizedOutputPath);
    let tsConfigPath = path_1.join(context.workspaceRoot, options.tsConfig);
    return rxjs_1.Observable.create((subscriber) => {
        if (projectDependencies.length > 0) {
            // const parsedTSConfig = readTsConfig(tsConfigPath);
            const parsedTSConfig = ts.readConfigFile(tsConfigPath, ts.sys.readFile)
                .config;
            // update TSConfig paths to point to the dist folder
            parsedTSConfig.compilerOptions = parsedTSConfig.compilerOptions || {};
            parsedTSConfig.compilerOptions.paths =
                parsedTSConfig.compilerOptions.paths || {};
            buildale_libs_utils_1.updatePaths(projectDependencies, parsedTSConfig.compilerOptions.paths);
            // find the library root folder
            const libRoot = projGraph.nodes[context.target.project].data.root;
            // write the tmp tsconfig needed for building
            const tmpTsConfigPath = path_1.join(context.workspaceRoot, libRoot, 'tsconfig.lib.nx-tmp');
            fileutils_1.writeJsonFile(tmpTsConfigPath, parsedTSConfig);
            // adjust the tsConfig path s.t. it points to the temporary one
            // with the adjusted paths
            tsConfigPath = tmpTsConfigPath;
        }
        try {
            let args = ['-p', tsConfigPath, '--outDir', options.normalizedOutputPath];
            if (options.sourceMap) {
                args.push('--sourceMap');
            }
            const tscPath = path_1.join(context.workspaceRoot, '/node_modules/typescript/bin/tsc');
            if (options.watch) {
                context.logger.info('Starting TypeScript watch');
                args.push('--watch');
                tscProcess = child_process_1.fork(tscPath, args, { stdio: [0, 1, 2, 'ipc'] });
                subscriber.next({ success: true });
            }
            else {
                context.logger.info(`Compiling TypeScript files for library ${context.target.project}...`);
                tscProcess = child_process_1.fork(tscPath, args, { stdio: [0, 1, 2, 'ipc'] });
                tscProcess.on('exit', code => {
                    if (code === 0) {
                        context.logger.info(`Done compiling TypeScript files for library ${context.target.project}`);
                        subscriber.next({ success: true });
                    }
                    else {
                        subscriber.error('Could not compile Typescript files');
                    }
                    subscriber.complete();
                });
            }
        }
        catch (error) {
            if (tscProcess) {
                killProcess(context);
            }
            subscriber.error(new Error(`Could not compile Typescript files: \n ${error}`));
        }
    }).pipe(operators_1.finalize(() => {
        cleanupTmpTsConfigFile(tsConfigPath);
    }));
}
function cleanupTmpTsConfigFile(tsConfigPath) {
    if (tsConfigPath.indexOf('.nx-tmp') > -1) {
        fs_1.unlinkSync(tsConfigPath);
    }
}
function killProcess(context) {
    return treeKill(tscProcess.pid, 'SIGTERM', error => {
        tscProcess = null;
        if (error) {
            if (Array.isArray(error) && error[0] && error[2]) {
                const errorMessage = error[2];
                context.logger.error(errorMessage);
            }
            else if (error.message) {
                context.logger.error(error.message);
            }
        }
    });
}
function updatePackageJson(options, context) {
    const mainFile = path_1.basename(options.main, '.ts');
    const typingsFile = `${mainFile}.d.ts`;
    const mainJsFile = `${mainFile}.js`;
    const packageJson = workspace_1.readJsonFile(path_1.join(context.workspaceRoot, options.packageJson));
    packageJson.main = path_1.normalize(`./${options.relativeMainFileOutput}/${mainJsFile}`);
    packageJson.typings = path_1.normalize(`./${options.relativeMainFileOutput}/${typingsFile}`);
    fileutils_1.writeJsonFile(`${options.outputPath}/package.json`, packageJson);
}
function copyAssetFiles(options, context) {
    context.logger.info('Copying asset files...');
    return Promise.all(options.files.map(file => fs_extra_1.copy(file.input, file.output)))
        .then(() => {
        context.logger.info('Done copying asset files.');
        return {
            success: true
        };
    })
        .catch((err) => {
        return {
            error: err.message,
            success: false
        };
    });
}
