"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
function default_1(schema) {
    return (host, context) => {
        const options = normalizeOptions(host, schema);
        return schematics_1.chain([
            schematics_1.externalSchematic('@nrwl/workspace', 'lib', schema),
            createFiles(options),
            updateTsConfig(options),
            addProject(options),
            workspace_1.formatFiles(options)
        ]);
    };
}
exports.default = default_1;
function normalizeOptions(host, options) {
    const defaultPrefix = workspace_1.getNpmScope(host);
    const name = workspace_1.toFileName(options.name);
    const projectDirectory = options.directory
        ? `${workspace_1.toFileName(options.directory)}/${name}`
        : name;
    const projectName = projectDirectory.replace(new RegExp('/', 'g'), '-');
    const fileName = projectName;
    const projectRoot = core_1.normalize(`libs/${projectDirectory}`);
    const parsedTags = options.tags
        ? options.tags.split(',').map(s => s.trim())
        : [];
    const normalized = Object.assign(Object.assign({}, options), { prefix: defaultPrefix, // we could also allow customizing this
        fileName, name: projectName, projectRoot,
        projectDirectory,
        parsedTags });
    return normalized;
}
function createFiles(options) {
    return schematics_1.mergeWith(schematics_1.apply(schematics_1.url(`./files/lib`), [
        schematics_1.template(Object.assign(Object.assign(Object.assign({}, options), workspace_1.names(options.name)), { tmpl: '', offsetFromRoot: workspace_1.offsetFromRoot(options.projectRoot) })),
        schematics_1.move(options.projectRoot),
        options.unitTestRunner === 'none'
            ? schematics_1.filter(file => !file.endsWith('spec.ts'))
            : schematics_1.noop(),
        options.publishable
            ? schematics_1.noop()
            : schematics_1.filter(file => !file.endsWith('package.json'))
    ]), schematics_1.MergeStrategy.Overwrite);
}
function updateTsConfig(options) {
    if (options.unitTestRunner === 'none') {
        return schematics_1.noop();
    }
    return (host, context) => {
        const projectConfig = workspace_1.getProjectConfig(host, options.name);
        return workspace_1.updateJsonInTree(`${projectConfig.root}/tsconfig.json`, json => {
            json.compilerOptions.types.push('jest');
            return json;
        });
    };
}
function addProject(options) {
    if (!options.publishable) {
        return schematics_1.noop();
    }
    return workspace_1.updateWorkspaceInTree(json => {
        const architect = json.projects[options.name].architect;
        if (architect) {
            architect.build = {
                builder: '@nrwl/node:package',
                options: {
                    outputPath: `dist/libs/${options.projectDirectory}`,
                    tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
                    packageJson: `${options.projectRoot}/package.json`,
                    main: `${options.projectRoot}/src/index.ts`,
                    assets: [`${options.projectRoot}/*.md`]
                }
            };
        }
        return json;
    });
}
