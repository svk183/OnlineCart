"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const execute_impl_1 = require("./execute.impl");
const rxjs_1 = require("rxjs");
const devkitArchitect = require("@angular-devkit/architect");
const testing_1 = require("../../utils/testing");
jest.mock('child_process');
let { fork } = require('child_process');
jest.mock('tree-kill');
let treeKill = require('tree-kill');
describe('NodeExecuteBuilder', () => {
    let testOptions;
    let context;
    let scheduleTargetAndForget;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        fork.mockReturnValue({
            pid: 123
        });
        treeKill.mockImplementation((pid, signal, callback) => {
            callback();
        });
        context = yield testing_1.getMockContext();
        context.addTarget({
            project: 'nodeapp',
            target: 'build'
        }, '@nrwl/node:build');
        testOptions = {
            inspect: true,
            args: [],
            buildTarget: 'nodeapp:build',
            port: 9229,
            waitUntilTargets: [],
            host: 'localhost',
            watch: true
        };
        scheduleTargetAndForget = spyOn(devkitArchitect, 'scheduleTargetAndForget').and.returnValue(rxjs_1.of({ success: true, outfile: 'outfile.js' }));
    }));
    it('should build the application and start the built file', () => __awaiter(this, void 0, void 0, function* () {
        yield execute_impl_1.nodeExecuteBuilderHandler(testOptions, context).toPromise();
        expect(scheduleTargetAndForget).toHaveBeenCalledWith(context, {
            project: 'nodeapp',
            target: 'build'
        }, {
            watch: true
        });
        expect(fork).toHaveBeenCalledWith('outfile.js', [], {
            execArgv: [
                '-r',
                'source-map-support/register',
                '--inspect=localhost:9229'
            ]
        });
        expect(treeKill).toHaveBeenCalledTimes(0);
        expect(fork).toHaveBeenCalledTimes(1);
    }));
    describe('--inspect', () => {
        describe('inspect', () => {
            it('should inspect the process', () => __awaiter(this, void 0, void 0, function* () {
                yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { inspect: "inspect" /* Inspect */ }), context).toPromise();
                expect(fork).toHaveBeenCalledWith('outfile.js', [], {
                    execArgv: [
                        '-r',
                        'source-map-support/register',
                        '--inspect=localhost:9229'
                    ]
                });
            }));
        });
        describe('inspect-brk', () => {
            it('should inspect and break at beginning of execution', () => __awaiter(this, void 0, void 0, function* () {
                yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { inspect: "inspect-brk" /* InspectBrk */ }), context).toPromise();
                expect(fork).toHaveBeenCalledWith('outfile.js', [], {
                    execArgv: [
                        '-r',
                        'source-map-support/register',
                        '--inspect=localhost:9229'
                    ]
                });
            }));
        });
    });
    describe('--host', () => {
        describe('0.0.0.0', () => {
            it('should inspect the process on host 0.0.0.0', () => __awaiter(this, void 0, void 0, function* () {
                yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { host: '0.0.0.0' }), context).toPromise();
                expect(fork).toHaveBeenCalledWith('outfile.js', [], {
                    execArgv: [
                        '-r',
                        'source-map-support/register',
                        '--inspect=localhost:9229'
                    ]
                });
            }));
        });
    });
    describe('--port', () => {
        describe('1234', () => {
            it('should inspect the process on port 1234', () => __awaiter(this, void 0, void 0, function* () {
                yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { port: 1234 }), context).toPromise();
                expect(fork).toHaveBeenCalledWith('outfile.js', [], {
                    execArgv: [
                        '-r',
                        'source-map-support/register',
                        '--inspect=localhost:1234'
                    ]
                });
            }));
        });
    });
    it('should log errors from killing the process', (done) => __awaiter(this, void 0, void 0, function* () {
        treeKill.mockImplementation((pid, signal, callback) => {
            callback(new Error('Error Message'));
        });
        const loggerError = spyOn(context.logger, 'error');
        scheduleTargetAndForget = scheduleTargetAndForget.and.returnValue(rxjs_1.from([
            { success: true, outfile: 'outfile.js' },
            { success: true, outfile: 'outfile.js' }
        ]));
        execute_impl_1.nodeExecuteBuilderHandler(testOptions, context).subscribe({
            complete: () => {
                expect(loggerError.calls.argsFor(1)).toEqual(['Error Message']);
                done();
            }
        });
    }));
    it('should log errors from killing the process on windows', () => __awaiter(this, void 0, void 0, function* () {
        treeKill.mockImplementation((pid, signal, callback) => {
            callback([new Error('error'), '', 'Error Message']);
        });
        const loggerError = spyOn(context.logger, 'error');
        scheduleTargetAndForget = scheduleTargetAndForget.and.returnValue(rxjs_1.from([
            { success: true, outfile: 'outfile.js' },
            { success: true, outfile: 'outfile.js' }
        ]));
        yield execute_impl_1.nodeExecuteBuilderHandler(testOptions, context).toPromise();
        expect(loggerError.calls.argsFor(1)).toEqual(['Error Message']);
    }));
    it('should build the application and start the built file with options', () => __awaiter(this, void 0, void 0, function* () {
        yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { inspect: false, args: ['arg1', 'arg2'] }), context).toPromise();
        expect(fork).toHaveBeenCalledWith('outfile.js', ['arg1', 'arg2'], {
            execArgv: ['-r', 'source-map-support/register']
        });
    }));
    it('should warn users who try to use it in production', () => __awaiter(this, void 0, void 0, function* () {
        spyOn(context, 'validateOptions').and.returnValue(Promise.resolve({
            optimization: true
        }));
        spyOn(context.logger, 'warn');
        yield execute_impl_1.nodeExecuteBuilderHandler(testOptions, context).toPromise();
        expect(context.logger.warn).toHaveBeenCalled();
    }));
    describe('waitUntilTasks', () => {
        it('should run the tasks before starting the build', () => __awaiter(this, void 0, void 0, function* () {
            scheduleTargetAndForget = scheduleTargetAndForget.and.returnValue(rxjs_1.of({ success: true }));
            yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { waitUntilTargets: ['project1:target1', 'project2:target2'] }), context).toPromise();
            expect(scheduleTargetAndForget).toHaveBeenCalledTimes(3);
            expect(scheduleTargetAndForget).toHaveBeenCalledWith(context, {
                project: 'project1',
                target: 'target1'
            });
            expect(scheduleTargetAndForget).toHaveBeenCalledWith(context, {
                project: 'project2',
                target: 'target2'
            });
        }));
        it('should not run the build if any of the tasks fail', () => __awaiter(this, void 0, void 0, function* () {
            scheduleTargetAndForget = scheduleTargetAndForget.and.callFake(target => rxjs_1.of({ success: target.target === 'project1' }));
            const loggerError = spyOn(context.logger, 'error');
            const output = yield execute_impl_1.nodeExecuteBuilderHandler(Object.assign({}, testOptions, { waitUntilTargets: ['project1:target1', 'project2:target2'] }), context).toPromise();
            expect(output).toEqual(jasmine.objectContaining({
                success: false
            }));
            expect(loggerError).toHaveBeenCalled();
        }));
    });
});
