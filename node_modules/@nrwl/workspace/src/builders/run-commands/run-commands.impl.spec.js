"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const tmp_1 = require("tmp");
const fs_1 = require("fs");
const testing_1 = require("@angular-devkit/architect/testing");
const architect_1 = require("@angular-devkit/architect");
const path_1 = require("path");
function readFile(f) {
    return fs_1.readFileSync(f)
        .toString()
        .replace(/\s/g, '');
}
describe('Command Runner Builder', () => {
    let architect;
    beforeEach(() => __awaiter(this, void 0, void 0, function* () {
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const testArchitectHost = new testing_1.TestingArchitectHost('/root', '/root');
        architect = new architect_1.Architect(testArchitectHost, registry);
        yield testArchitectHost.addBuilderFromPackage(path_1.join(__dirname, '../../..'));
    }));
    // TODO re-enable test when https://github.com/angular/angular-cli/pull/14315 is merged
    xit('should error when no commands are given', () => __awaiter(this, void 0, void 0, function* () {
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {});
            yield run.output.toPromise();
            fail('should throw');
        }
        catch (e) {
            expect(e).toEqual(`ERROR: Bad builder config for @nrwl/run-command - "command" option is required`);
        }
    }));
    // TODO re-enable test when https://github.com/angular/angular-cli/pull/14315 is merged
    xit('should error when no command is given', () => __awaiter(this, void 0, void 0, function* () {
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [{}]
            });
            yield run.result;
            fail('should throw');
        }
        catch (e) {
            expect(e).toEqual(`ERROR: Bad builder config for @nrwl/run-command - "command" option is required`);
        }
    }));
    describe('no readyCondition', () => {
        it('should run commands serially', () => __awaiter(this, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `sleep 0.2 && echo 1 >> ${f}`
                    },
                    {
                        command: `sleep 0.1 && echo 2 >> ${f}`
                    }
                ],
                parallel: false
            });
            const result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            expect(readFile(f)).toEqual('12');
        }));
        it('should run commands in parallel', () => __awaiter(this, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `sleep 0.2 && echo 1 >> ${f}`
                    },
                    {
                        command: `sleep 0.1 && echo 2 >> ${f}`
                    }
                ],
                parallel: true
            });
            const result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            expect(readFile(f)).toEqual('21');
        }));
    });
    describe('readyWhen', () => {
        it('should error when parallel = false', () => __awaiter(this, void 0, void 0, function* () {
            try {
                const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                    commands: [{ command: 'some command' }],
                    parallel: false,
                    readyWhen: 'READY'
                });
                yield run.result;
                fail('should throw');
            }
            catch (e) {
                expect(e).toEqual(`ERROR: Bad builder config for @nrwl/run-command - "readyWhen" can only be used when parallel=true`);
            }
        }));
        it('should return success true when the string specified is ready condition is found', (done) => __awaiter(this, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo READY && sleep 0.1 && echo 1 >> ${f}`
                    }
                ],
                parallel: true,
                readyWhen: 'READY'
            });
            let successEmitted = false;
            run.output.subscribe(result => {
                successEmitted = true;
                expect(result.success).toEqual(true);
                expect(readFile(f)).toEqual('');
            });
            setTimeout(() => {
                expect(successEmitted).toEqual(true);
                expect(readFile(f)).toEqual('1');
                done();
            }, 150);
        }));
    });
    it('should stop execution when a command fails', () => __awaiter(this, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `echo 1 >> ${f} && exit 1`
                },
                {
                    command: `echo 2 >> ${f}`
                }
            ],
            parallel: false
        });
        const result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: false }));
        expect(readFile(f)).toEqual('1');
    }));
    it('should throw when invalid args', () => __awaiter(this, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo {args.key} >> ${f}`
                    }
                ],
                args: 'key=value'
            });
            yield run.result;
        }
        catch (e) {
            expect(e.message).toEqual('Invalid args: key=value');
        }
    }));
    it('should enable parameter substitution', () => __awaiter(this, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `echo {args.key} >> ${f}`
                }
            ],
            args: '--key=value'
        });
        const result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: true }));
        expect(readFile(f)).toEqual('value');
    }));
});
