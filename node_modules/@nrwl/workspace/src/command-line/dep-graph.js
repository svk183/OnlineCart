"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const http = require("http");
const opn = require("opn");
const deps_calculator_1 = require("./deps-calculator");
const shared_1 = require("./shared");
const output_1 = require("./output");
function startServer(projects, deps, affected) {
    const f = fs_1.readFileSync(__dirname + '/dep-graph/dep-graph.html').toString();
    const html = f
        .replace(`window.projects = null`, `window.projects = ${JSON.stringify(projects)}`)
        .replace(`window.deps = null`, `window.deps = ${JSON.stringify(deps)}`)
        .replace(`window.affected = null`, `window.affected = ${JSON.stringify(affected)}`);
    const app = http.createServer((req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/html' });
        res.end(html);
    });
    app.listen(4211, '127.0.0.1');
    output_1.output.note({
        title: 'Dep graph started at http://localhost:4211'
    });
    opn('http://localhost:4211', {
        wait: false
    });
}
exports.startServer = startServer;
function generateGraph(args, affectedProjects) {
    const workspaceJson = shared_1.readWorkspaceJson();
    const nxJson = shared_1.readNxJson();
    const projects = shared_1.getProjectNodes(workspaceJson, nxJson);
    const deps = deps_calculator_1.readDependencies(nxJson.npmScope, projects);
    const renderProjects = filterProjects(deps, projects, args.filter, args.exclude);
    if (args.file) {
        fs_1.writeFileSync(args.file, JSON.stringify({
            deps,
            affectedProjects,
            criticalPath: affectedProjects
        }, null, 2));
    }
    else {
        startServer(renderProjects, deps, affectedProjects);
    }
}
exports.generateGraph = generateGraph;
function filterProjects(deps, projects, filter, exclude) {
    const filteredProjects = projects.filter(p => {
        const filtered = filter && filter.length > 0
            ? filter.find(f => hasPath(deps, f, p.name, []) || hasPath(deps, p.name, f, []))
            : true;
        return !exclude
            ? filtered
            : exclude && exclude.indexOf(p.name) === -1 && filtered;
    });
    return filteredProjects;
}
exports.filterProjects = filterProjects;
function hasPath(deps, target, node, visited) {
    if (target === node)
        return true;
    for (let d of deps[node]) {
        if (visited.indexOf(d.projectName) > -1)
            continue;
        if (hasPath(deps, target, d.projectName, [...visited, d.projectName]))
            return true;
    }
    return false;
}
exports.hasPath = hasPath;
