"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ts = require("typescript");
const shared_1 = require("./shared");
const fs_1 = require("fs");
const fileutils_1 = require("../utils/fileutils");
const strip_source_code_1 = require("../utils/strip-source-code");
const app_root_1 = require("../utils/app-root");
var DependencyType;
(function (DependencyType) {
    DependencyType["es6Import"] = "es6Import";
    DependencyType["loadChildren"] = "loadChildren";
    DependencyType["implicit"] = "implicit";
})(DependencyType = exports.DependencyType || (exports.DependencyType = {}));
function readDependencies(npmScope, projectNodes) {
    const nxDepsPath = `${app_root_1.appRootPath}/dist/nxdeps.json`;
    const m = shared_1.lastModifiedAmongProjectFiles(projectNodes);
    if (!fileutils_1.directoryExists(`${app_root_1.appRootPath}/dist`)) {
        fs_1.mkdirSync(`${app_root_1.appRootPath}/dist`);
    }
    const existingDeps = fileutils_1.fileExists(nxDepsPath) ? fileutils_1.readJsonFile(nxDepsPath) : null;
    if (!existingDeps || m > shared_1.mtime(nxDepsPath)) {
        return dependencies(npmScope, projectNodes, existingDeps, (f) => fs_1.readFileSync(`${app_root_1.appRootPath}/${f}`, 'UTF-8'));
    }
    else {
        return existingDeps.dependencies;
    }
}
exports.readDependencies = readDependencies;
/**
 * DO NOT USE
 * Only exported for unit testing
 *
 * USE `readDependencies`
 */
function dependencies(npmScope, projects, existingDependencies, fileRead) {
    const nxDepsPath = `${app_root_1.appRootPath}/dist/nxdeps.json`;
    const nxDepsExists = fileutils_1.fileExists(nxDepsPath);
    const nxDepsMTime = nxDepsExists ? shared_1.mtime(nxDepsPath) : -Infinity;
    const calculator = new DepsCalculator(npmScope, projects, existingDependencies, fileRead);
    projects
        .filter(project => !calculator.incrementalEnabled ||
        shared_1.getProjectMTime(project) >= nxDepsMTime)
        .forEach(project => {
        project.files
            .filter(file => !calculator.incrementalEnabled ||
            !project.fileMTimes[file] ||
            project.fileMTimes[file] >= nxDepsMTime)
            .forEach(file => {
            calculator.processFile(file);
        });
    });
    calculator.commitDeps(nxDepsPath);
    return calculator.getDeps();
}
exports.dependencies = dependencies;
/**
 * Class for calculating dependencies between projects by processing files.
 */
class DepsCalculator {
    constructor(npmScope, projects, existingDeps, fileRead) {
        this.npmScope = npmScope;
        this.projects = projects;
        this.existingDeps = existingDeps;
        this.fileRead = fileRead;
        this.scanner = ts.createScanner(ts.ScriptTarget.Latest, false);
        this.projects.sort((a, b) => {
            if (!a.root)
                return -1;
            if (!b.root)
                return -1;
            return a.root.length > b.root.length ? -1 : 1;
        });
        this._incremental = this.shouldIncrementallyRecalculate();
        this.deps = this.initializeDeps();
    }
    get incrementalEnabled() {
        return this._incremental;
    }
    /**
     * Write the current state of dependencies to a file
     * @param path Path of file to write to
     */
    commitDeps(path) {
        this.deps.dependencies = this.getDeps();
        const files = this.deps.files;
        // This removes files with no dependencies from the cache because it doesn't matter.
        Object.entries(files).forEach(([key, val]) => {
            if (!val || val.length < 1) {
                delete files[key];
            }
        });
        fileutils_1.writeToFile(path, JSON.stringify(Object.assign({}, this.deps, { files })));
    }
    /**
     * Retrieve the current dependencies
     */
    getDeps() {
        const dependencies = this.projects.reduce((deps, project) => {
            const dependencies = project.files
                .map(file => this.deps.files[file] || [])
                .reduce((arr, deps) => {
                return [
                    ...arr,
                    ...deps.filter(dep => !arr.some(item => item.projectName === dep.projectName))
                ];
            }, [])
                .filter(dep => dep.projectName !== project.name);
            return Object.assign({}, deps, { [project.name]: dependencies });
        }, {});
        this.setImplicitDepsFromProjects(dependencies, this.projects);
        return dependencies;
    }
    /**
     * Process a file and update it's dependencies
     */
    processFile(filePath) {
        const extension = path.extname(filePath);
        if (extension !== '.ts' &&
            extension !== '.tsx' &&
            extension !== '.js' &&
            extension !== '.jsx') {
            return;
        }
        this.deps.files[filePath] = [];
        const content = this.fileRead(filePath);
        const strippedContent = strip_source_code_1.stripSourceCode(this.scanner, content);
        if (strippedContent !== '') {
            const tsFile = ts.createSourceFile(filePath, strippedContent, ts.ScriptTarget.Latest, true);
            this.processNode(filePath, tsFile);
        }
    }
    isLegacyFormat(existingDeps) {
        return !existingDeps.dependencies && !existingDeps.files;
    }
    shouldIncrementallyRecalculate() {
        if (!this.existingDeps || this.isLegacyFormat(this.existingDeps)) {
            return false;
        }
        const currentProjects = this.projects.map(p => p.name).sort();
        const previousProjects = Object.keys(this.existingDeps.dependencies).sort();
        return (currentProjects.length === previousProjects.length &&
            !currentProjects.some((val, index) => val !== previousProjects[index]));
    }
    initializeDeps() {
        const files = [];
        this.projects.forEach(p => {
            files.push(...p.files);
        });
        const dependencies = this.projects.reduce((m, c) => (Object.assign({}, m, { [c.name]: [] })), {});
        const fileDependencies = {};
        files.forEach(file => {
            fileDependencies[file] = this.incrementalEnabled
                ? this.existingDeps.files[file] || []
                : [];
        });
        return {
            dependencies,
            files: fileDependencies
        };
    }
    setImplicitDepsFromProjects(deps, projects) {
        projects.forEach(project => {
            if (project.implicitDependencies.length === 0) {
                return;
            }
            project.implicitDependencies.forEach(depName => {
                this.setDependencyIfNotAlreadySet(deps, project.name, depName, DependencyType.implicit);
            });
        });
    }
    processNode(filePath, node) {
        if (ts.isImportDeclaration(node) ||
            (ts.isExportDeclaration(node) && node.moduleSpecifier)) {
            const imp = this.getStringLiteralValue(node.moduleSpecifier);
            this.addDepIfNeeded(imp, filePath, DependencyType.es6Import);
            return; // stop traversing downwards
        }
        if (ts.isCallExpression(node) &&
            node.expression.kind === ts.SyntaxKind.ImportKeyword &&
            node.arguments.length === 1 &&
            ts.isStringLiteral(node.arguments[0])) {
            const imp = this.getStringLiteralValue(node.arguments[0]);
            this.addDepIfNeeded(imp, filePath, DependencyType.loadChildren);
            return;
        }
        if (node.kind === ts.SyntaxKind.PropertyAssignment) {
            const name = this.getPropertyAssignmentName(node.name);
            if (name === 'loadChildren') {
                const init = node.initializer;
                if (init.kind === ts.SyntaxKind.StringLiteral) {
                    const childrenExpr = this.getStringLiteralValue(init);
                    this.addDepIfNeeded(childrenExpr, filePath, DependencyType.loadChildren);
                    return; // stop traversing downwards
                }
            }
        }
        /**
         * Continue traversing down the AST from the current node
         */
        ts.forEachChild(node, child => this.processNode(filePath, child));
    }
    getPropertyAssignmentName(nameNode) {
        switch (nameNode.kind) {
            case ts.SyntaxKind.Identifier:
                return nameNode.getText();
            case ts.SyntaxKind.StringLiteral:
                return nameNode.text;
            default:
                return null;
        }
    }
    addDepIfNeeded(expr, filePath, depType) {
        const matchingProject = this.projects.filter(a => {
            const normalizedRoot = shared_1.normalizedProjectRoot(a);
            return (expr === `@${this.npmScope}/${normalizedRoot}` ||
                expr.startsWith(`@${this.npmScope}/${normalizedRoot}#`) ||
                expr.startsWith(`@${this.npmScope}/${normalizedRoot}/`));
        })[0];
        if (matchingProject) {
            this.setDependencyIfNotAlreadySet(this.deps.files, filePath, matchingProject.name, depType);
        }
    }
    setDependencyIfNotAlreadySet(deps, key, depTarget, depType) {
        const alreadyHasDep = deps[key].some(d => d.projectName === depTarget && d.type === depType);
        if (!alreadyHasDep) {
            const dep = { projectName: depTarget, type: depType };
            deps[key].push(dep);
        }
    }
    getStringLiteralValue(node) {
        return node.getText().substr(1, node.getText().length - 2);
    }
}
exports.DepsCalculator = DepsCalculator;
