"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const dep_graph_1 = require("../dep-graph");
const output_1 = require("../output");
const shared_1 = require("../shared");
const utils_1 = require("../../tasks-runner/utils");
const run_command_1 = require("./run-command");
const utils_2 = require("./utils");
function affected(command, parsedArgs) {
    const env = utils_2.readEnvironment(parsedArgs.target);
    const affectedMetadata = shared_1.getProjectMetadata(parsedArgs.all ? [] : shared_1.parseFiles(parsedArgs).files, parsedArgs.withDeps);
    const projects = (parsedArgs.all
        ? getAllProjects(affectedMetadata)
        : getAffectedProjects(affectedMetadata))
        .filter(app => !parsedArgs.exclude.includes(app.name))
        .filter(project => !parsedArgs.onlyFailed || !env.workspace.getResult(project.name));
    try {
        switch (command) {
            case 'apps':
                const apps = projects
                    .filter(p => p.type === shared_1.ProjectType.app)
                    .map(p => p.name);
                if (parsedArgs.plain) {
                    console.log(apps.join(' '));
                }
                else {
                    shared_1.printArgsWarning(parsedArgs);
                    if (apps.length) {
                        output_1.output.log({
                            title: 'Affected apps:',
                            bodyLines: apps.map(app => `${output_1.output.colors.gray('-')} ${app}`)
                        });
                    }
                }
                break;
            case 'libs':
                const libs = projects
                    .filter(p => p.type === shared_1.ProjectType.lib)
                    .map(p => p.name);
                if (parsedArgs.plain) {
                    console.log(libs.join(' '));
                }
                else {
                    shared_1.printArgsWarning(parsedArgs);
                    if (libs.length) {
                        output_1.output.log({
                            title: 'Affected libs:',
                            bodyLines: libs.map(lib => `${output_1.output.colors.gray('-')} ${lib}`)
                        });
                    }
                }
                break;
            case 'print-affected':
                const { args, projectWithTargetAndConfig } = allProjectsWithTargetAndConfiguration(projects, parsedArgs);
                printAffected(projectWithTargetAndConfig, affectedMetadata, args);
                break;
            case 'dep-graph': {
                const projectNames = projects.map(p => p.name);
                shared_1.printArgsWarning(parsedArgs);
                dep_graph_1.generateGraph(parsedArgs, projectNames);
                break;
            }
            case 'affected': {
                const { args, projectWithTargetAndConfig } = allProjectsWithTargetAndConfiguration(projects, parsedArgs);
                shared_1.printArgsWarning(parsedArgs);
                run_command_1.runCommand(projectWithTargetAndConfig, affectedMetadata.dependencyGraph, args, env);
                break;
            }
        }
    }
    catch (e) {
        printError(e, parsedArgs.verbose);
        process.exit(1);
    }
}
exports.affected = affected;
function allProjectsWithTargetAndConfiguration(projects, parsedArgs) {
    const args = utils_2.splitArgs(parsedArgs, nxSpecificFlags);
    const projectWithTargetAndConfig = projects.filter(p => projectHasTargetAndConfiguration(p, args.nxArgs.target, args.nxArgs.configuration));
    return { args, projectWithTargetAndConfig };
}
function projectHasTargetAndConfiguration(project, target, configuration) {
    if (!project.architect[target]) {
        return false;
    }
    if (!configuration) {
        return !!project.architect[target];
    }
    else {
        return (project.architect[target].configurations &&
            project.architect[target].configurations[configuration]);
    }
}
function getAffectedProjects(affectedMetadata) {
    return filterAffectedMetadata(affectedMetadata, project => affectedMetadata.projectStates[project.name].affected);
}
function getAllProjects(affectedMetadata) {
    return filterAffectedMetadata(affectedMetadata, () => true);
}
function filterAffectedMetadata(affectedMetadata, predicate) {
    const projects = [];
    visit(affectedMetadata, project => {
        if (predicate(project)) {
            projects.push(project);
        }
    });
    return projects;
}
function visit(affectedMetadata, visitor) {
    const visited = new Set();
    function _visit(projectName) {
        if (visited.has(projectName)) {
            return;
        }
        visited.add(projectName);
        affectedMetadata.dependencyGraph.dependencies[projectName].forEach(dep => {
            _visit(dep.projectName);
        });
        visitor(affectedMetadata.dependencyGraph.projects[projectName]);
    }
    affectedMetadata.dependencyGraph.roots.forEach(root => {
        _visit(root);
    });
}
function printError(e, verbose) {
    const bodyLines = [e.message];
    if (verbose && e.stack) {
        bodyLines.push('');
        bodyLines.push(e.stack);
    }
    output_1.output.error({
        title: 'There was a critical error when running your command',
        bodyLines
    });
}
function printAffected(affectedProjects, affectedMetadata, args) {
    const tasks = affectedProjects.map(affectedProject => run_command_1.createTask({
        project: affectedProject,
        target: args.nxArgs.target,
        configuration: args.nxArgs.configuration,
        overrides: args.overrides
    }));
    const cli = shared_1.cliCommand();
    const isYarn = path_1.basename(process.env.npm_execpath || 'npm').startsWith('yarn');
    const tasksJson = tasks.map(task => ({
        id: task.id,
        overrides: task.overrides,
        target: task.target,
        command: `${isYarn ? 'yarn' : 'npm run'} ${utils_1.getCommand(cli, isYarn, task)}`,
        outputs: utils_1.getOutputs(affectedMetadata.dependencyGraph.projects, task)
    }));
    console.log(JSON.stringify({
        tasks: tasksJson,
        dependencyGraph: affectedMetadata.dependencyGraph
    }, null, 2));
}
/**
 * These options are only for getting an array with properties of AffectedOptions.
 *
 * @remark They are not defaults or useful for anything else
 */
const dummyOptions = {
    target: '',
    configuration: '',
    onlyFailed: false,
    'only-failed': false,
    untracked: false,
    uncommitted: false,
    runner: '',
    help: false,
    version: false,
    quiet: false,
    all: false,
    base: 'base',
    head: 'head',
    exclude: ['exclude'],
    files: [''],
    verbose: false,
    plain: false
};
const nxSpecificFlags = Object.keys(dummyOptions);
