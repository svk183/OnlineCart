"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tasks_runner_1 = require("../../tasks-runner/tasks-runner");
const default_tasks_runner_1 = require("../../tasks-runner/default-tasks-runner");
const fileutils_1 = require("../../utils/fileutils");
const path_1 = require("path");
const app_root_1 = require("../../utils/app-root");
const default_reporter_1 = require("./default-reporter");
const utils_1 = require("./utils");
function runCommand(projectsToRun, dependencyGraph, { nxArgs, overrides, targetArgs }, { nxJson, workspace }) {
    const reporter = new default_reporter_1.DefaultReporter();
    reporter.beforeRun(projectsToRun.map(p => p.name), nxArgs, overrides);
    const tasks = projectsToRun.map(project => createTask({
        project,
        target: nxArgs.target,
        configuration: nxArgs.configuration,
        overrides: overrides
    }));
    const tasksMap = {};
    Object.entries(dependencyGraph.projects).forEach(([projectName, project]) => {
        const runnable = utils_1.projectHasTargetAndConfiguration(project, nxArgs.target, nxArgs.configuration);
        if (runnable) {
            tasksMap[projectName] = {
                [nxArgs.target]: createTask({
                    project: project,
                    target: nxArgs.target,
                    configuration: nxArgs.configuration,
                    overrides: overrides
                })
            };
        }
    });
    const { tasksRunner, tasksOptions } = getRunner(nxArgs.runner, nxJson, targetArgs);
    tasksRunner(tasks, tasksOptions, {
        dependencyGraph: dependencyGraph,
        tasksMap
    }).subscribe({
        next: (event) => {
            switch (event.type) {
                case tasks_runner_1.AffectedEventType.TaskComplete: {
                    workspace.setResult(event.task.target.project, event.success);
                }
            }
        },
        error: console.error,
        complete: () => {
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
            workspace.saveResults();
            reporter.printResults(nxArgs, workspace.failedProjects, workspace.startedWithFailedProjects);
            if (workspace.hasFailure) {
                process.exit(1);
            }
        }
    });
}
exports.runCommand = runCommand;
function createTask({ project, target, configuration, overrides }) {
    return {
        id: getId({
            project: project.name,
            target: target,
            configuration: configuration
        }),
        target: {
            project: project.name,
            target,
            configuration
        },
        overrides: interpolateOverrides(overrides, project.name, project)
    };
}
exports.createTask = createTask;
function getId({ project, target, configuration }) {
    let id = project + ':' + target;
    if (configuration) {
        id += ':' + configuration;
    }
    return id;
}
function getRunner(runner, nxJson, targetArgs) {
    if (!nxJson.tasksRunnerOptions) {
        return {
            tasksRunner: default_tasks_runner_1.defaultTasksRunner,
            tasksOptions: targetArgs
        };
    }
    if (!runner && !nxJson.tasksRunnerOptions.default) {
        return {
            tasksRunner: default_tasks_runner_1.defaultTasksRunner,
            tasksOptions: targetArgs
        };
    }
    runner = runner || 'default';
    if (nxJson.tasksRunnerOptions[runner]) {
        let modulePath = nxJson.tasksRunnerOptions[runner].runner;
        if (fileutils_1.isRelativePath(modulePath)) {
            modulePath = path_1.join(app_root_1.appRootPath, modulePath);
        }
        return {
            tasksRunner: require(modulePath),
            tasksOptions: Object.assign({}, nxJson.tasksRunnerOptions[runner].options, targetArgs)
        };
    }
    else {
        throw new Error(`Could not find runner configuration for ${runner}`);
    }
}
exports.getRunner = getRunner;
function interpolateOverrides(args, projectName, projectMetadata) {
    const interpolatedArgs = Object.assign({}, args);
    Object.entries(interpolatedArgs).forEach(([name, value]) => {
        if (typeof value === 'string') {
            const regex = /{project\.([^}]+)}/g;
            interpolatedArgs[name] = value.replace(regex, (_, group) => {
                if (group.includes('.')) {
                    throw new Error('Only top-level properties can be interpolated');
                }
                if (group === 'name') {
                    return projectName;
                }
                return projectMetadata[group];
            });
        }
    });
    return interpolatedArgs;
}
