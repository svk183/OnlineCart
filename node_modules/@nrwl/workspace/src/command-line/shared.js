"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = require("fs");
const path = require("path");
const app_root_1 = require("../utils/app-root");
const fileutils_1 = require("../utils/fileutils");
const deps_calculator_1 = require("./deps-calculator");
const touched_1 = require("./touched");
const output_1 = require("./output");
const ignore = require('ignore');
exports.TEN_MEGABYTES = 1024 * 10000;
var ProjectType;
(function (ProjectType) {
    ProjectType["app"] = "app";
    ProjectType["e2e"] = "e2e";
    ProjectType["lib"] = "lib";
})(ProjectType = exports.ProjectType || (exports.ProjectType = {}));
function readFileIfExisting(path) {
    return fs.existsSync(path) ? fs.readFileSync(path, 'UTF-8').toString() : '';
}
function getIgnoredGlobs() {
    const ig = ignore();
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.gitignore`));
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.nxignore`));
    return ig;
}
function printArgsWarning(options) {
    const { files, uncommitted, untracked, base, head, all } = options;
    if (!files &&
        !uncommitted &&
        !untracked &&
        !base &&
        !head &&
        !all &&
        options._.length < 2) {
        output_1.output.note({
            title: `Affected criteria defaulted to --base=${output_1.output.bold('master')} --head=${output_1.output.bold('HEAD')}`
        });
    }
    if (all) {
        output_1.output.warn({
            title: `Running affected:* commands with --all can result in very slow builds.`,
            bodyLines: [
                output_1.output.bold('--all') +
                    ' is not meant to be used for any sizable project or to be used in CI.',
                '',
                output_1.output.colors.gray('Learn more about checking only what is affected: ') + 'https://nx.dev/guides/monorepo-affected.'
            ]
        });
    }
}
exports.printArgsWarning = printArgsWarning;
function parseFiles(options) {
    const { files, uncommitted, untracked, base, head } = options;
    if (files) {
        return {
            files
        };
    }
    else if (uncommitted) {
        return {
            files: getUncommittedFiles()
        };
    }
    else if (untracked) {
        return {
            files: getUntrackedFiles()
        };
    }
    else if (base && head) {
        return {
            files: getFilesUsingBaseAndHead(base, head)
        };
    }
    else if (base) {
        return {
            files: Array.from(new Set([
                ...getFilesUsingBaseAndHead(base, 'HEAD'),
                ...getUncommittedFiles(),
                ...getUntrackedFiles()
            ]))
        };
    }
    else if (options._.length >= 2) {
        return {
            files: getFilesFromShash(options._[1], options._[2])
        };
    }
    else {
        return {
            files: Array.from(new Set([
                ...getFilesUsingBaseAndHead('master', 'HEAD'),
                ...getUncommittedFiles(),
                ...getUntrackedFiles()
            ]))
        };
    }
}
exports.parseFiles = parseFiles;
function getUncommittedFiles() {
    return parseGitOutput(`git diff --name-only --relative HEAD .`);
}
function getUntrackedFiles() {
    return parseGitOutput(`git ls-files --others --exclude-standard`);
}
function getFilesUsingBaseAndHead(base, head) {
    const mergeBase = child_process_1.execSync(`git merge-base ${base} ${head}`, {
        maxBuffer: exports.TEN_MEGABYTES
    })
        .toString()
        .trim();
    return parseGitOutput(`git diff --name-only --relative ${mergeBase} ${head}`);
}
function getFilesFromShash(sha1, sha2) {
    return parseGitOutput(`git diff --name-only --relative ${sha1} ${sha2}`);
}
function parseGitOutput(command) {
    return child_process_1.execSync(command, { maxBuffer: exports.TEN_MEGABYTES })
        .toString('utf-8')
        .split('\n')
        .map(a => a.trim())
        .filter(a => a.length > 0);
}
function getFileLevelImplicitDependencies(projects, nxJson) {
    if (!nxJson.implicitDependencies) {
        return {};
    }
    Object.entries(nxJson.implicitDependencies).forEach(([key, value]) => {
        if (value === '*') {
            nxJson.implicitDependencies[key] = projects.map(p => p.name);
        }
    });
    return nxJson.implicitDependencies;
}
function getProjectLevelImplicitDependencies(projects) {
    const implicitDependencies = projects.reduce((memo, project) => {
        project.implicitDependencies.forEach(dep => {
            if (memo[dep]) {
                memo[dep].add(project.name);
            }
            else {
                memo[dep] = new Set([project.name]);
            }
        });
        return memo;
    }, {});
    return Object.entries(implicitDependencies).reduce((memo, [key, val]) => {
        memo[key] = Array.from(val);
        return memo;
    }, {});
}
function detectAndSetInvalidProjectValues(map, sourceName, desiredProjectNames, validProjects) {
    const invalidProjects = desiredProjectNames.filter(projectName => !validProjects[projectName]);
    if (invalidProjects.length > 0) {
        map.set(sourceName, invalidProjects);
    }
}
function getImplicitDependencies(projects, workspaceJson, nxJson) {
    assertWorkspaceValidity(workspaceJson, nxJson);
    const implicitFileDeps = getFileLevelImplicitDependencies(projects, nxJson);
    const implicitProjectDeps = getProjectLevelImplicitDependencies(projects);
    return {
        files: implicitFileDeps,
        projects: implicitProjectDeps
    };
}
exports.getImplicitDependencies = getImplicitDependencies;
function assertWorkspaceValidity(workspaceJson, nxJson) {
    const workspaceJsonProjects = Object.keys(workspaceJson.projects);
    const nxJsonProjects = Object.keys(nxJson.projects);
    if (minus(workspaceJsonProjects, nxJsonProjects).length > 0) {
        throw new Error(`${workspaceFileName()} and nx.json are out of sync. The following projects are missing in nx.json: ${minus(workspaceJsonProjects, nxJsonProjects).join(', ')}`);
    }
    if (minus(nxJsonProjects, workspaceJsonProjects).length > 0) {
        throw new Error(`${workspaceFileName()} and nx.json are out of sync. The following projects are missing in ${workspaceFileName()}: ${minus(nxJsonProjects, workspaceJsonProjects).join(', ')}`);
    }
    const projects = Object.assign({}, workspaceJson.projects, nxJson.projects);
    const invalidImplicitDependencies = new Map();
    Object.entries(nxJson.implicitDependencies || {})
        .filter(([_, val]) => val !== '*') // These are valid since it is calculated
        .reduce((map, [filename, projectNames]) => {
        detectAndSetInvalidProjectValues(map, filename, projectNames, projects);
        return map;
    }, invalidImplicitDependencies);
    nxJsonProjects
        .filter(nxJsonProjectName => {
        const project = nxJson.projects[nxJsonProjectName];
        return !!project.implicitDependencies;
    })
        .reduce((map, nxJsonProjectName) => {
        const project = nxJson.projects[nxJsonProjectName];
        detectAndSetInvalidProjectValues(map, nxJsonProjectName, project.implicitDependencies, projects);
        return map;
    }, invalidImplicitDependencies);
    if (invalidImplicitDependencies.size === 0) {
        return;
    }
    let message = `The following implicitDependencies specified in nx.json are invalid:
  `;
    invalidImplicitDependencies.forEach((projectNames, key) => {
        const str = `  ${key}
    ${projectNames.map(projectName => `    ${projectName}`).join('\n')}`;
        message += str;
    });
    throw new Error(message);
}
exports.assertWorkspaceValidity = assertWorkspaceValidity;
function getProjectNodes(workspaceJson, nxJson) {
    assertWorkspaceValidity(workspaceJson, nxJson);
    const workspaceJsonProjects = Object.keys(workspaceJson.projects);
    return workspaceJsonProjects.map(key => {
        const p = workspaceJson.projects[key];
        const tags = nxJson.projects[key].tags;
        const projectType = p.projectType === 'application'
            ? key.endsWith('-e2e')
                ? ProjectType.e2e
                : ProjectType.app
            : ProjectType.lib;
        let implicitDependencies = nxJson.projects[key].implicitDependencies || [];
        if (projectType === ProjectType.e2e && implicitDependencies.length === 0) {
            implicitDependencies = [key.replace(/-e2e$/, '')];
        }
        const filesWithMTimes = allFilesInDir(`${app_root_1.appRootPath}/${p.root}`);
        const fileMTimes = {};
        filesWithMTimes.forEach(f => {
            fileMTimes[f.file] = f.mtime;
        });
        return {
            name: key,
            root: p.root,
            type: projectType,
            tags,
            architect: p.architect || {},
            files: filesWithMTimes.map(f => f.file),
            implicitDependencies,
            fileMTimes
        };
    });
}
exports.getProjectNodes = getProjectNodes;
function minus(a, b) {
    const res = [];
    a.forEach(aa => {
        if (!b.find(bb => bb === aa)) {
            res.push(aa);
        }
    });
    return res;
}
function cliCommand() {
    return workspaceFileName() === 'angular.json' ? 'ng' : 'nx';
}
exports.cliCommand = cliCommand;
function readWorkspaceJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/${workspaceFileName()}`);
}
exports.readWorkspaceJson = readWorkspaceJson;
function workspaceFileName() {
    const packageJson = readPackageJson();
    if (packageJson.devDependencies['@angular/cli'] ||
        packageJson.dependencies['@angular/cli']) {
        return 'angular.json';
    }
    else {
        return 'workspace.json';
    }
}
exports.workspaceFileName = workspaceFileName;
function readPackageJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/package.json`);
}
exports.readPackageJson = readPackageJson;
function readNxJson() {
    const config = fileutils_1.readJsonFile(`${app_root_1.appRootPath}/nx.json`);
    if (!config.npmScope) {
        throw new Error(`nx.json must define the npmScope property.`);
    }
    return config;
}
exports.readNxJson = readNxJson;
function getProjectMetadata(touchedFiles, withDeps) {
    const workspaceJson = readWorkspaceJson();
    const nxJson = readNxJson();
    const projectNodes = getProjectNodes(workspaceJson, nxJson);
    const implicitDeps = getImplicitDependencies(projectNodes, workspaceJson, nxJson);
    const dependencies = deps_calculator_1.readDependencies(nxJson.npmScope, projectNodes);
    const tp = touched_1.touchedProjects(implicitDeps, projectNodes, touchedFiles);
    return createProjectMetadata(projectNodes, dependencies, tp, withDeps);
}
exports.getProjectMetadata = getProjectMetadata;
function createProjectMetadata(projectNodes, dependencies, touchedProjects, withDeps) {
    const projectStates = {};
    const projects = {};
    projectNodes.forEach(project => {
        projectStates[project.name] = {
            touched: false,
            affected: false
        };
        projects[project.name] = project;
    });
    const reverseDeps = reverseDependencies(dependencies);
    const roots = projectNodes
        .filter(project => !reverseDeps[project.name])
        .map(project => project.name);
    touchedProjects.forEach(projectName => {
        projectStates[projectName].touched = true;
        setAffected(projectName, simplifyDeps(dependencies), reverseDeps, projectStates, withDeps);
    });
    return {
        dependencyGraph: {
            projects,
            dependencies,
            roots
        },
        projectStates
    };
}
exports.createProjectMetadata = createProjectMetadata;
function simplifyDeps(dependencies) {
    const res = {};
    Object.keys(dependencies).forEach(d => {
        res[d] = dependencies[d].map(dd => dd.projectName);
    });
    return res;
}
function reverseDependencies(dependencies) {
    const reverseDepSets = {};
    Object.entries(dependencies).forEach(([depName, deps]) => {
        deps.forEach(dep => {
            reverseDepSets[dep.projectName] =
                reverseDepSets[dep.projectName] || new Set();
            reverseDepSets[dep.projectName].add(depName);
        });
    });
    return Object.entries(reverseDepSets).reduce((reverseDeps, [name, depSet]) => {
        reverseDeps[name] = Array.from(depSet);
        return reverseDeps;
    }, {});
}
function setAffected(projectName, deps, reverseDeps, projectStates, withDeps) {
    projectStates[projectName].affected = true;
    const rdep = reverseDeps[projectName] || [];
    rdep.forEach(dep => {
        // If a dependency is already marked as affected, it means it has been visited
        if (projectStates[dep].affected) {
            return;
        }
        setAffected(dep, deps, reverseDeps, projectStates, withDeps);
    });
    if (withDeps) {
        setDeps(projectName, deps, reverseDeps, projectStates);
    }
}
function setDeps(projectName, deps, reverseDeps, projectStates) {
    projectStates[projectName].affected = true;
    deps[projectName].forEach(dep => {
        // If a dependency is already marked as affected, it means it has been visited
        if (projectStates[dep].affected) {
            return;
        }
        setDeps(dep, deps, reverseDeps, projectStates);
    });
}
function getProjectRoots(projectNames) {
    const { projects } = readWorkspaceJson();
    return projectNames.map(name => projects[name].root);
}
exports.getProjectRoots = getProjectRoots;
function allFilesInDir(dirName) {
    const ignoredGlobs = getIgnoredGlobs();
    if (ignoredGlobs.ignores(path.relative(app_root_1.appRootPath, dirName))) {
        return [];
    }
    let res = [];
    try {
        fs.readdirSync(dirName).forEach(c => {
            const child = path.join(dirName, c);
            if (ignoredGlobs.ignores(path.relative(app_root_1.appRootPath, child))) {
                return;
            }
            try {
                const s = fs.statSync(child);
                if (!s.isDirectory()) {
                    // add starting with "apps/myapp/..." or "libs/mylib/..."
                    res.push({
                        file: normalizePath(path.relative(app_root_1.appRootPath, child)),
                        mtime: s.mtimeMs
                    });
                }
                else if (s.isDirectory()) {
                    res = [...res, ...allFilesInDir(child)];
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    return res;
}
exports.allFilesInDir = allFilesInDir;
function lastModifiedAmongProjectFiles(projects) {
    return Math.max(...[
        ...projects.map(project => getProjectMTime(project)),
        mtime(`${app_root_1.appRootPath}/${workspaceFileName()}`),
        mtime(`${app_root_1.appRootPath}/nx.json`),
        mtime(`${app_root_1.appRootPath}/tslint.json`),
        mtime(`${app_root_1.appRootPath}/package.json`)
    ]);
}
exports.lastModifiedAmongProjectFiles = lastModifiedAmongProjectFiles;
function getProjectMTime(project) {
    return Math.max(...Object.values(project.fileMTimes));
}
exports.getProjectMTime = getProjectMTime;
/**
 * Returns the time when file was last modified
 * Returns -Infinity for a non-existent file
 */
function mtime(filePath) {
    if (!fs.existsSync(filePath)) {
        return -Infinity;
    }
    return fs.statSync(filePath).mtimeMs;
}
exports.mtime = mtime;
function normalizePath(file) {
    return file.split(path.sep).join('/');
}
function normalizedProjectRoot(p) {
    return p.root
        .split('/')
        .filter(v => !!v)
        .slice(1)
        .join('/');
}
exports.normalizedProjectRoot = normalizedProjectRoot;
