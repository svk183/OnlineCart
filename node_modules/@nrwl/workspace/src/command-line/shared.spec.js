"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("./shared");
const deps_calculator_1 = require("./deps-calculator");
describe('assertWorkspaceValidity', () => {
    let mockNxJson;
    let mockWorkspaceJson;
    beforeEach(() => {
        mockNxJson = {
            projects: {
                app1: {
                    tags: []
                },
                'app1-e2e': {
                    tags: []
                },
                app2: {
                    tags: []
                },
                'app2-e2e': {
                    tags: []
                },
                lib1: {
                    tags: []
                },
                lib2: {
                    tags: []
                }
            }
        };
        mockWorkspaceJson = {
            projects: {
                app1: {},
                'app1-e2e': {},
                app2: {},
                'app2-e2e': {},
                lib1: {},
                lib2: {}
            }
        };
    });
    it('should not throw for a valid workspace', () => {
        shared_1.assertWorkspaceValidity(mockWorkspaceJson, mockNxJson);
    });
    it('should throw for a missing project in workspace.json', () => {
        delete mockWorkspaceJson.projects.app1;
        try {
            shared_1.assertWorkspaceValidity(mockWorkspaceJson, mockNxJson);
            fail('Did not throw');
        }
        catch (e) {
            expect(e.message).toContain('projects are missing in');
        }
    });
    it('should throw for a missing project in nx.json', () => {
        delete mockNxJson.projects.app1;
        try {
            shared_1.assertWorkspaceValidity(mockWorkspaceJson, mockNxJson);
            fail('Did not throw');
        }
        catch (e) {
            expect(e.message).toContain('projects are missing in nx.json');
        }
    });
    it('should throw for an invalid top-level implicit dependency', () => {
        mockNxJson.implicitDependencies = {
            'README.md': ['invalidproj']
        };
        try {
            shared_1.assertWorkspaceValidity(mockWorkspaceJson, mockNxJson);
            fail('Did not throw');
        }
        catch (e) {
            expect(e.message).toContain('implicitDependencies specified in nx.json are invalid');
            expect(e.message).toContain('  README.md');
            expect(e.message).toContain('    invalidproj');
        }
    });
    it('should throw for an invalid project-level implicit dependency', () => {
        mockNxJson.projects.app2.implicitDependencies = ['invalidproj'];
        try {
            shared_1.assertWorkspaceValidity(mockWorkspaceJson, mockNxJson);
            fail('Did not throw');
        }
        catch (e) {
            expect(e.message).toContain('implicitDependencies specified in nx.json are invalid');
            expect(e.message).toContain('  app2');
            expect(e.message).toContain('    invalidproj');
        }
    });
});
describe('getImplicitDependencies', () => {
    let mockNxJson;
    let mockworkspaceJson;
    beforeEach(() => {
        mockNxJson = {
            npmScope: 'proj',
            projects: {
                app1: {
                    tags: []
                },
                'app1-e2e': {
                    tags: []
                },
                app2: {
                    tags: []
                },
                'app2-e2e': {
                    tags: []
                },
                lib1: {
                    tags: []
                },
                lib2: {
                    tags: []
                }
            }
        };
        mockworkspaceJson = {
            projects: {
                app1: {
                    projectType: 'application'
                },
                'app1-e2e': {
                    projectType: 'application'
                },
                app2: {
                    projectType: 'application'
                },
                'app2-e2e': {
                    projectType: 'application'
                },
                lib1: {
                    projectType: 'library'
                },
                lib2: {
                    projectType: 'library'
                }
            }
        };
    });
    describe('top-level implicit dependencies', () => {
        it('should return implicit dependencies', () => {
            mockNxJson.implicitDependencies = {
                Jenkinsfile: ['app1', 'app2']
            };
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {
                    Jenkinsfile: ['app1', 'app2']
                },
                projects: {
                    app1: ['app1-e2e'],
                    app2: ['app2-e2e']
                }
            });
        });
        it('should normalize wildcards into all projects', () => {
            mockNxJson.implicitDependencies = {
                'package.json': '*'
            };
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {
                    'package.json': [
                        'app1',
                        'app1-e2e',
                        'app2',
                        'app2-e2e',
                        'lib1',
                        'lib2'
                    ]
                },
                projects: {
                    app1: ['app1-e2e'],
                    app2: ['app2-e2e']
                }
            });
        });
        it('should call throw for an invalid workspace', () => {
            delete mockNxJson.projects.app1;
            try {
                shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
                fail('did not throw');
            }
            catch (e) { }
        });
    });
    describe('project-based implicit dependencies', () => {
        it('should default appropriately', () => {
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {},
                projects: {
                    app1: ['app1-e2e'],
                    app2: ['app2-e2e']
                }
            });
        });
        it('should allow setting on libs and apps', () => {
            mockNxJson.projects.app2.implicitDependencies = ['app1'];
            mockNxJson.projects.lib2.implicitDependencies = ['lib1'];
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {},
                projects: {
                    app1: ['app1-e2e', 'app2'],
                    app2: ['app2-e2e'],
                    lib1: ['lib2']
                }
            });
        });
        // NOTE: originally e2e apps had a magic dependency on their target app by naming convention.
        // So, 'appName-e2e' depended on 'appName'.
        it('should override magic e2e dependencies if specified', () => {
            mockNxJson.projects['app1-e2e'].implicitDependencies = ['app2'];
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {},
                projects: {
                    app2: ['app1-e2e', 'app2-e2e']
                }
            });
        });
        it('should fallback to magic e2e dependencies if empty array specified', () => {
            mockNxJson.projects['app1-e2e'].implicitDependencies = [];
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {},
                projects: {
                    app1: ['app1-e2e'],
                    app2: ['app2-e2e']
                }
            });
        });
    });
    describe('project-based and top-level implicit dependencies', () => {
        it('allows setting both', () => {
            mockNxJson.implicitDependencies = {
                Jenkinsfile: ['app1', 'app2']
            };
            mockNxJson.projects.app2.implicitDependencies = ['app1'];
            const result = shared_1.getImplicitDependencies(shared_1.getProjectNodes(mockworkspaceJson, mockNxJson), mockworkspaceJson, mockNxJson);
            expect(result).toEqual({
                files: {
                    Jenkinsfile: ['app1', 'app2']
                },
                projects: {
                    app1: ['app1-e2e', 'app2'],
                    app2: ['app2-e2e']
                }
            });
        });
    });
});
describe('getProjectNodes', () => {
    let mockNxJson;
    let mockworkspaceJson;
    beforeEach(() => {
        mockNxJson = {
            projects: {
                app1: {
                    tags: []
                },
                'app1-e2e': {
                    tags: []
                },
                'customName-e2e': {
                    tags: []
                },
                lib1: {
                    tags: []
                },
                lib2: {
                    tags: []
                }
            }
        };
        mockworkspaceJson = {
            projects: {
                app1: {
                    projectType: 'application'
                },
                'app1-e2e': {
                    projectType: 'application'
                },
                'customName-e2e': {
                    projectType: 'application'
                },
                lib1: {
                    projectType: 'library'
                },
                lib2: {
                    projectType: 'library'
                }
            }
        };
    });
    it('should parse nodes as correct type', () => {
        const result = shared_1.getProjectNodes(mockworkspaceJson, mockNxJson).map(node => {
            return { name: node.name, type: node.type };
        });
        expect(result).toEqual([
            {
                name: 'app1',
                type: shared_1.ProjectType.app
            },
            {
                name: 'app1-e2e',
                type: shared_1.ProjectType.e2e
            },
            {
                name: 'customName-e2e',
                type: shared_1.ProjectType.e2e
            },
            {
                name: 'lib1',
                type: shared_1.ProjectType.lib
            },
            {
                name: 'lib2',
                type: shared_1.ProjectType.lib
            }
        ]);
    });
    it('should normalize missing architect configurations to an empty object', () => {
        const result = shared_1.getProjectNodes(mockworkspaceJson, mockNxJson).map(node => {
            return { name: node.name, architect: node.architect };
        });
        expect(result).toEqual([
            {
                name: 'app1',
                architect: {}
            },
            {
                name: 'app1-e2e',
                architect: {}
            },
            {
                name: 'customName-e2e',
                architect: {}
            },
            {
                name: 'lib1',
                architect: {}
            },
            {
                name: 'lib2',
                architect: {}
            }
        ]);
    });
});
describe('createAffectedMetadata', () => {
    let projectNodes;
    let dependencies;
    beforeEach(() => {
        projectNodes = [
            {
                name: 'app1'
            },
            {
                name: 'app2'
            },
            {
                name: 'app1-e2e'
            },
            {
                name: 'customName-e2e'
            },
            {
                name: 'lib1'
            },
            {
                name: 'lib2'
            }
        ];
        dependencies = {
            'app1-e2e': [
                {
                    projectName: 'app1',
                    type: deps_calculator_1.DependencyType.implicit
                }
            ],
            'customName-e2e': [
                {
                    projectName: 'app2',
                    type: deps_calculator_1.DependencyType.implicit
                }
            ],
            app1: [
                {
                    projectName: 'lib1',
                    type: deps_calculator_1.DependencyType.es6Import
                }
            ],
            app2: [
                {
                    projectName: 'lib1',
                    type: deps_calculator_1.DependencyType.es6Import
                },
                {
                    projectName: 'lib2',
                    type: deps_calculator_1.DependencyType.es6Import
                }
            ],
            lib1: [],
            lib2: []
        };
    });
    it('should translate project nodes array to map', () => {
        expect(shared_1.createProjectMetadata(projectNodes, dependencies, [], false).dependencyGraph.projects).toEqual({
            app1: {
                name: 'app1'
            },
            app2: {
                name: 'app2'
            },
            'app1-e2e': {
                name: 'app1-e2e'
            },
            'customName-e2e': {
                name: 'customName-e2e'
            },
            lib1: {
                name: 'lib1'
            },
            lib2: {
                name: 'lib2'
            }
        });
    });
    it('should include the dependencies', () => {
        expect(shared_1.createProjectMetadata(projectNodes, dependencies, [], false).dependencyGraph.dependencies).toEqual(dependencies);
    });
    it('should find the roots', () => {
        expect(shared_1.createProjectMetadata(projectNodes, dependencies, [], false).dependencyGraph.roots).toEqual(['app1-e2e', 'customName-e2e']);
    });
    it('should set projects as touched', () => {
        const { projectStates } = shared_1.createProjectMetadata(projectNodes, dependencies, ['app1', 'lib2'], false);
        expect(projectStates.app1.touched).toEqual(true);
        expect(projectStates.lib2.touched).toEqual(true);
        expect(projectStates.lib1.touched).toEqual(false);
        expect(projectStates.app2.touched).toEqual(false);
        expect(projectStates['customName-e2e'].touched).toEqual(false);
        expect(projectStates['app1-e2e'].touched).toEqual(false);
    });
    it('should set touched projects as affected', () => {
        const { projectStates } = shared_1.createProjectMetadata(projectNodes, dependencies, ['app1', 'lib2'], false);
        expect(projectStates.app1.affected).toEqual(true);
        expect(projectStates.lib2.affected).toEqual(true);
    });
    it('should set dependents of touched projects as affected', () => {
        const { projectStates } = shared_1.createProjectMetadata(projectNodes, dependencies, ['app1'], false);
        expect(projectStates.app1.affected).toEqual(true);
        expect(projectStates['app1-e2e'].affected).toEqual(true);
        expect(projectStates.lib1.affected).toEqual(false);
        expect(projectStates.lib2.affected).toEqual(false);
        expect(projectStates.app2.affected).toEqual(false);
        expect(projectStates['customName-e2e'].affected).toEqual(false);
    });
    it('should set dependents of touched projects as affected (2)', () => {
        const { projectStates } = shared_1.createProjectMetadata(projectNodes, dependencies, ['lib1'], false);
        expect(projectStates.app1.affected).toEqual(true);
        expect(projectStates['app1-e2e'].affected).toEqual(true);
        expect(projectStates.lib1.affected).toEqual(true);
        expect(projectStates.app2.affected).toEqual(true);
        expect(projectStates['customName-e2e'].affected).toEqual(true);
        expect(projectStates.lib2.affected).toEqual(false);
    });
    it('should not set any projects as affected when none are touched', () => {
        const { projectStates } = shared_1.createProjectMetadata(projectNodes, dependencies, [], false);
        expect(projectStates.app1.affected).toEqual(false);
        expect(projectStates.app2.affected).toEqual(false);
        expect(projectStates.lib1.affected).toEqual(false);
        expect(projectStates.lib2.affected).toEqual(false);
        expect(projectStates['app1-e2e'].affected).toEqual(false);
        expect(projectStates['customName-e2e'].affected).toEqual(false);
    });
    it('should handle circular dependencies', () => {
        dependencies['lib2'].push({
            projectName: 'app2',
            type: deps_calculator_1.DependencyType.es6Import
        });
        const metadata = shared_1.createProjectMetadata(projectNodes, dependencies, ['lib2'], false);
        const { dependencyGraph, projectStates } = metadata;
        expect(dependencyGraph.roots).toEqual(['app1-e2e', 'customName-e2e']);
        expect(projectStates.app1.affected).toEqual(false);
        expect(projectStates.app2.affected).toEqual(true);
        expect(projectStates.lib1.affected).toEqual(false);
        expect(projectStates.lib2.affected).toEqual(true);
        expect(projectStates['app1-e2e'].affected).toEqual(false);
        expect(projectStates['customName-e2e'].affected).toEqual(true);
    });
    it('should cases where there is no root', () => {
        dependencies['lib1'].push({
            projectName: 'app1-e2e',
            type: deps_calculator_1.DependencyType.es6Import
        });
        dependencies['lib2'].push({
            projectName: 'customName-e2e',
            type: deps_calculator_1.DependencyType.es6Import
        });
        const metadata = shared_1.createProjectMetadata(projectNodes, dependencies, ['app1-e2e', 'customName-e2e'], false);
        const { dependencyGraph, projectStates } = metadata;
        expect(dependencyGraph.roots).toEqual([]);
        expect(projectStates.app1.affected).toEqual(true);
        expect(projectStates.app2.affected).toEqual(true);
        expect(projectStates.lib1.affected).toEqual(true);
        expect(projectStates.lib2.affected).toEqual(true);
        expect(projectStates['app1-e2e'].affected).toEqual(true);
        expect(projectStates['customName-e2e'].affected).toEqual(true);
    });
});
