"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const runAll = require("npm-run-all");
const rxjs_1 = require("rxjs");
const path_1 = require("path");
const tasks_runner_1 = require("./tasks-runner");
const shared_1 = require("../command-line/shared");
const output_1 = require("../command-line/output");
const fileutils_1 = require("../utils/fileutils");
const utils_1 = require("./utils");
exports.defaultTasksRunner = (tasks, options) => {
    const cli = shared_1.cliCommand();
    const isYarn = path_1.basename(process.env.npm_execpath || 'npm').startsWith('yarn');
    assertPackageJsonScriptExists(cli);
    const additionalTaskOverrides = getLegacyTaskOverrides(options);
    tasks.forEach(task => {
        task.overrides = Object.assign({}, task.overrides, additionalTaskOverrides);
    });
    const commands = tasks.map(t => utils_1.getCommand(cli, isYarn, t));
    return new rxjs_1.Observable(subscriber => {
        runAll(commands, {
            parallel: options.parallel || false,
            maxParallel: options.maxParallel || 3,
            continueOnError: true,
            stdin: process.stdin,
            stdout: process.stdout,
            stderr: process.stderr
        })
            .then(() => {
            tasks.forEach(task => {
                subscriber.next({
                    task: task,
                    type: tasks_runner_1.AffectedEventType.TaskComplete,
                    success: true
                });
            });
        })
            .catch(e => {
            e.results.forEach((result, i) => {
                subscriber.next({
                    task: tasks[i],
                    type: tasks_runner_1.AffectedEventType.TaskComplete,
                    success: result.code === 0
                });
            });
        })
            .finally(() => {
            subscriber.complete();
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
        });
    });
};
function getLegacyTaskOverrides(options) {
    const legacyTaskOverrides = Object.assign({}, options);
    delete legacyTaskOverrides.maxParallel;
    delete legacyTaskOverrides['max-parallel'];
    delete legacyTaskOverrides.parallel;
    delete legacyTaskOverrides.verbose;
    return legacyTaskOverrides;
}
function assertPackageJsonScriptExists(cli) {
    // Make sure the `package.json` has the `nx: "nx"` command needed by `npm-run-all`
    const packageJson = fileutils_1.readJsonFile('./package.json');
    if (!packageJson.scripts || !packageJson.scripts[cli]) {
        output_1.output.error({
            title: `The "scripts" section of your 'package.json' must contain "${cli}": "${cli}"`,
            bodyLines: [
                output_1.output.colors.gray('...'),
                ' "scripts": {',
                output_1.output.colors.gray('  ...'),
                `   "${cli}": "${cli}"`,
                output_1.output.colors.gray('  ...'),
                ' }',
                output_1.output.colors.gray('...')
            ]
        });
        return process.exit(1);
    }
}
exports.default = exports.defaultTasksRunner;
