"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Lint = require("tslint");
const deps_calculator_1 = require("../command-line/deps-calculator");
const shared_1 = require("../command-line/shared");
const app_root_1 = require("../utils/app-root");
const runtime_lint_utils_1 = require("../utils/runtime-lint-utils");
const core_1 = require("@angular-devkit/core");
class Rule extends Lint.Rules.AbstractRule {
    constructor(options, projectPath, npmScope, projectNodes, deps) {
        super(options);
        this.projectPath = projectPath;
        this.npmScope = npmScope;
        this.projectNodes = projectNodes;
        this.deps = deps;
        if (!projectPath) {
            this.projectPath = core_1.normalize(app_root_1.appRootPath);
            if (!global.projectNodes) {
                const workspaceJson = shared_1.readWorkspaceJson();
                const nxJson = shared_1.readNxJson();
                global.npmScope = nxJson.npmScope;
                global.projectNodes = shared_1.getProjectNodes(workspaceJson, nxJson);
                global.deps = deps_calculator_1.readDependencies(global.npmScope, global.projectNodes);
            }
            this.npmScope = global.npmScope;
            this.projectNodes = global.projectNodes;
            this.deps = global.deps;
        }
    }
    apply(sourceFile) {
        return this.applyWithWalker(new EnforceModuleBoundariesWalker(sourceFile, this.getOptions(), this.projectPath, this.npmScope, this.projectNodes, this.deps));
    }
}
exports.Rule = Rule;
class EnforceModuleBoundariesWalker extends Lint.RuleWalker {
    constructor(sourceFile, options, projectPath, npmScope, projectNodes, deps) {
        super(sourceFile, options);
        this.projectPath = projectPath;
        this.npmScope = npmScope;
        this.projectNodes = projectNodes;
        this.deps = deps;
        this.projectNodes.sort((a, b) => {
            if (!a.root)
                return -1;
            if (!b.root)
                return -1;
            return a.root.length > b.root.length ? -1 : 1;
        });
        this.allow = Array.isArray(this.getOptions()[0].allow)
            ? this.getOptions()[0].allow.map(a => `${a}`)
            : [];
        this.depConstraints = Array.isArray(this.getOptions()[0].depConstraints)
            ? this.getOptions()[0].depConstraints
            : [];
    }
    visitImportDeclaration(node) {
        const imp = node.moduleSpecifier
            .getText()
            .substring(1, node.moduleSpecifier.getText().length - 1);
        // whitelisted import
        if (this.allow.some(a => runtime_lint_utils_1.matchImportWithWildcard(a, imp))) {
            super.visitImportDeclaration(node);
            return;
        }
        // check for relative and absolute imports
        if (runtime_lint_utils_1.isRelativeImportIntoAnotherProject(imp, this.projectPath, this.projectNodes, runtime_lint_utils_1.getSourceFilePath(core_1.normalize(this.getSourceFile().fileName), this.projectPath)) ||
            runtime_lint_utils_1.isAbsoluteImportIntoAnotherProject(imp)) {
            this.addFailureAt(node.getStart(), node.getWidth(), `library imports must start with @${this.npmScope}/`);
            return;
        }
        // check constraints between libs and apps
        if (imp.startsWith(`@${this.npmScope}/`)) {
            // we should find the name
            const sourceProject = runtime_lint_utils_1.findSourceProject(this.projectNodes, runtime_lint_utils_1.getSourceFilePath(this.getSourceFile().fileName, this.projectPath));
            // findProjectUsingImport to take care of same prefix
            const targetProject = runtime_lint_utils_1.findProjectUsingImport(this.projectNodes, this.npmScope, imp);
            // something went wrong => return.
            if (!sourceProject || !targetProject) {
                super.visitImportDeclaration(node);
                return;
            }
            // check for circular dependency
            if (runtime_lint_utils_1.isCircular(this.deps, sourceProject, targetProject)) {
                const error = `Circular dependency between "${sourceProject.name}" and "${targetProject.name}" detected`;
                this.addFailureAt(node.getStart(), node.getWidth(), error);
                return;
            }
            // same project => allow
            if (sourceProject === targetProject) {
                super.visitImportDeclaration(node);
                return;
            }
            // cannot import apps
            if (targetProject.type !== shared_1.ProjectType.lib) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'imports of apps are forbidden');
                return;
            }
            // deep imports aren't allowed
            if (imp !== `@${this.npmScope}/${shared_1.normalizedProjectRoot(targetProject)}`) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'deep imports into libraries are forbidden');
                return;
            }
            // if we import a library using loadChildre, we should not import it using es6imports
            if (runtime_lint_utils_1.onlyLoadChildren(this.deps, sourceProject.name, targetProject.name, [])) {
                this.addFailureAt(node.getStart(), node.getWidth(), 'imports of lazy-loaded libraries are forbidden');
                return;
            }
            // check that dependency constraints are satisfied
            if (this.depConstraints.length > 0) {
                const constraints = runtime_lint_utils_1.findConstraintsFor(this.depConstraints, sourceProject);
                // when no constrains found => error. Force the user to provision them.
                if (constraints.length === 0) {
                    this.addFailureAt(node.getStart(), node.getWidth(), `A project without tags cannot depend on any libraries`);
                    return;
                }
                for (let constraint of constraints) {
                    if (runtime_lint_utils_1.hasNoneOfTheseTags(targetProject, constraint.onlyDependOnLibsWithTags || [])) {
                        const allowedTags = constraint.onlyDependOnLibsWithTags
                            .map(s => `"${s}"`)
                            .join(', ');
                        const error = `A project tagged with "${constraint.sourceTag}" can only depend on libs tagged with ${allowedTags}`;
                        this.addFailureAt(node.getStart(), node.getWidth(), error);
                        return;
                    }
                }
            }
        }
        super.visitImportDeclaration(node);
    }
}
