"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Lifted in part from https://github.com/nrwl/angular-console
const fs_1 = require("fs");
const path = require("path");
const fileutils_1 = require("./fileutils");
function getPluginVersion(workspaceRoot, name) {
    try {
        const packageJson = fileutils_1.readJsonFile(path.join(workspaceRoot, 'node_modules', name, 'package.json'));
        return packageJson.version;
    }
    catch (_a) {
        throw new Error(`Could not read package.json for module ${name}`);
    }
}
exports.getPluginVersion = getPluginVersion;
function readCapabilitiesFromNodeModules(workspaceRoot) {
    const packages = listOfUnnestedNpmPackages(workspaceRoot);
    return packages
        .map(name => getPluginCapabilities(workspaceRoot, name))
        .filter(x => x && !!(x.schematics || x.builders));
}
exports.readCapabilitiesFromNodeModules = readCapabilitiesFromNodeModules;
function getPluginCapabilities(workspaceRoot, pluginName) {
    try {
        const pluginPath = path.join(workspaceRoot, 'node_modules', pluginName);
        const packageJson = fileutils_1.readJsonFile(path.join(pluginPath, 'package.json'));
        return {
            name: pluginName,
            schematics: tryGetCollection(pluginPath, packageJson.schematics, 'schematics'),
            builders: tryGetCollection(pluginPath, packageJson.builders, 'builders')
        };
    }
    catch (_a) {
        return null;
    }
}
exports.getPluginCapabilities = getPluginCapabilities;
function tryGetCollection(pluginPath, jsonFile, propName) {
    if (!jsonFile) {
        return null;
    }
    try {
        return fileutils_1.readJsonFile(path.join(pluginPath, jsonFile))[propName];
    }
    catch (_a) {
        return null;
    }
}
let packageList = [];
function listOfUnnestedNpmPackages(workspaceRoot, requery = false) {
    if (!requery && packageList.length > 0) {
        return packageList;
    }
    const nodeModulesDir = path.join(workspaceRoot, 'node_modules');
    fs_1.readdirSync(nodeModulesDir).forEach(npmPackageOrScope => {
        if (npmPackageOrScope.startsWith('@')) {
            fs_1.readdirSync(path.join(nodeModulesDir, npmPackageOrScope)).forEach(p => {
                packageList.push(`${npmPackageOrScope}/${p}`);
            });
        }
        else {
            packageList.push(npmPackageOrScope);
        }
    });
    return packageList;
}
exports.listOfUnnestedNpmPackages = listOfUnnestedNpmPackages;
