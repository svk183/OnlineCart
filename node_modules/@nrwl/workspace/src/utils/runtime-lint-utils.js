"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const deps_calculator_1 = require("../command-line/deps-calculator");
const shared_1 = require("../command-line/shared");
const core_1 = require("@angular-devkit/core");
function hasNoneOfTheseTags(proj, tags) {
    return tags.filter(allowedTag => hasTag(proj, allowedTag)).length === 0;
}
exports.hasNoneOfTheseTags = hasNoneOfTheseTags;
function hasTag(proj, tag) {
    return (proj.tags || []).indexOf(tag) > -1 || tag === '*';
}
function containsFile(files, targetFileWithoutExtension) {
    return !!files.filter(f => removeExt(f) === targetFileWithoutExtension)[0];
}
function removeExt(file) {
    return file.replace(/\.[^/.]+$/, '');
}
function removeWindowsDriveLetter(osSpecificPath) {
    return osSpecificPath.replace(/^[A-Z]:/, '');
}
function normalizePath(osSpecificPath) {
    return removeWindowsDriveLetter(osSpecificPath)
        .split(path.sep)
        .join('/');
}
function matchImportWithWildcard(
// This may or may not contain wildcards ("*")
allowableImport, extractedImport) {
    if (allowableImport.endsWith('/**')) {
        const prefix = allowableImport.substring(0, allowableImport.length - 2);
        return extractedImport.startsWith(prefix);
    }
    else if (allowableImport.endsWith('/*')) {
        const prefix = allowableImport.substring(0, allowableImport.length - 1);
        if (!extractedImport.startsWith(prefix))
            return false;
        return extractedImport.substring(prefix.length).indexOf('/') === -1;
    }
    else if (allowableImport.indexOf('/**/') > -1) {
        const [prefix, suffix] = allowableImport.split('/**/');
        return (extractedImport.startsWith(prefix) && extractedImport.endsWith(suffix));
    }
    else {
        return new RegExp(allowableImport).test(extractedImport);
    }
}
exports.matchImportWithWildcard = matchImportWithWildcard;
function isRelative(s) {
    return s.startsWith('.');
}
exports.isRelative = isRelative;
function isRelativeImportIntoAnotherProject(imp, projectPath, projectNodes, sourceFilePath) {
    if (!isRelative(imp))
        return false;
    const targetFile = normalizePath(path.resolve(path.join(projectPath, path.dirname(sourceFilePath)), imp)).substring(projectPath.length + 1);
    const sourceProject = findSourceProject(projectNodes, sourceFilePath);
    const targetProject = findTargetProject(projectNodes, targetFile);
    return sourceProject && targetProject && sourceProject !== targetProject;
}
exports.isRelativeImportIntoAnotherProject = isRelativeImportIntoAnotherProject;
function findProjectUsingFile(projectNodes, file) {
    return projectNodes.filter(n => containsFile(n.files, file))[0];
}
exports.findProjectUsingFile = findProjectUsingFile;
function findSourceProject(projectNodes, sourceFilePath) {
    const targetFile = removeExt(sourceFilePath);
    return findProjectUsingFile(projectNodes, targetFile);
}
exports.findSourceProject = findSourceProject;
function findTargetProject(projectNodes, targetFile) {
    let targetProject = findProjectUsingFile(projectNodes, targetFile);
    if (!targetProject) {
        targetProject = findProjectUsingFile(projectNodes, normalizePath(path.join(targetFile, 'index')));
    }
    if (!targetProject) {
        targetProject = findProjectUsingFile(projectNodes, normalizePath(path.join(targetFile, 'src', 'index')));
    }
    return targetProject;
}
exports.findTargetProject = findTargetProject;
function isAbsoluteImportIntoAnotherProject(imp) {
    return (imp.startsWith('libs/') ||
        imp.startsWith('/libs/') ||
        imp.startsWith('apps/') ||
        imp.startsWith('/apps/'));
}
exports.isAbsoluteImportIntoAnotherProject = isAbsoluteImportIntoAnotherProject;
function findProjectUsingImport(projectNodes, npmScope, imp) {
    const unscopedImport = imp.substring(npmScope.length + 2);
    return projectNodes.filter(n => {
        const normalizedRoot = shared_1.normalizedProjectRoot(n);
        return (unscopedImport === normalizedRoot ||
            unscopedImport.startsWith(`${normalizedRoot}/`));
    })[0];
}
exports.findProjectUsingImport = findProjectUsingImport;
function isCircular(deps, sourceProject, targetProject) {
    if (!deps[targetProject.name])
        return false;
    return isDependingOn(deps, targetProject.name, sourceProject.name);
}
exports.isCircular = isCircular;
function isDependingOn(deps, sourceProjectName, targetProjectName, done = {}) {
    if (done[sourceProjectName])
        return false;
    if (!deps[sourceProjectName])
        return false;
    return deps[sourceProjectName]
        .map(dep => dep.projectName === targetProjectName
        ? true
        : isDependingOn(deps, dep.projectName, targetProjectName, Object.assign({}, done, { [`${sourceProjectName}`]: true })))
        .some(result => result);
}
function findConstraintsFor(depConstraints, sourceProject) {
    return depConstraints.filter(f => hasTag(sourceProject, f.sourceTag));
}
exports.findConstraintsFor = findConstraintsFor;
function onlyLoadChildren(deps, sourceProjectName, targetProjectName, visited) {
    if (visited.indexOf(sourceProjectName) > -1)
        return false;
    return ((deps[sourceProjectName] || []).filter(d => {
        if (d.type !== deps_calculator_1.DependencyType.loadChildren)
            return false;
        if (d.projectName === targetProjectName)
            return true;
        return onlyLoadChildren(deps, d.projectName, targetProjectName, [
            ...visited,
            sourceProjectName
        ]);
    }).length > 0);
}
exports.onlyLoadChildren = onlyLoadChildren;
function getSourceFilePath(sourceFileName, projectPath) {
    return core_1.normalize(sourceFileName).substring(projectPath.length + 1);
}
exports.getSourceFilePath = getSourceFilePath;
